// Generated by the protocol buffer compiler.  DO NOT EDIT!

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "FwmNcProtocol.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace FwmNcProto {

namespace {

const ::google::protobuf::Descriptor* GpuResourceInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GpuResourceInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* ResourceInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ResourceInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* FrameworkInstanceInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FrameworkInstanceInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* FrameworkResourceInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FrameworkResourceInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* DockerImageInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DockerImageInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* NetAddress_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NetAddress_reflection_ = NULL;
const ::google::protobuf::Descriptor* StartSlave_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  StartSlave_reflection_ = NULL;
const ::google::protobuf::Descriptor* RespondStartSlave_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RespondStartSlave_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_FwmNcProtocol_2eproto() {
  protobuf_AddDesc_FwmNcProtocol_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "FwmNcProtocol.proto");
  GOOGLE_CHECK(file != NULL);
  GpuResourceInfo_descriptor_ = file->message_type(0);
  static const int GpuResourceInfo_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GpuResourceInfo, gpu_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GpuResourceInfo, gpu_mem_size_),
  };
  GpuResourceInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GpuResourceInfo_descriptor_,
      GpuResourceInfo::default_instance_,
      GpuResourceInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GpuResourceInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GpuResourceInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GpuResourceInfo));
  ResourceInfo_descriptor_ = file->message_type(1);
  static const int ResourceInfo_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceInfo, cpu_num_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceInfo, cpu_mem_size_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceInfo, gpu_num_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceInfo, gpu_resource_info_),
  };
  ResourceInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ResourceInfo_descriptor_,
      ResourceInfo::default_instance_,
      ResourceInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ResourceInfo));
  FrameworkInstanceInfo_descriptor_ = file->message_type(2);
  static const int FrameworkInstanceInfo_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkInstanceInfo, framework_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkInstanceInfo, framework_instance_id_),
  };
  FrameworkInstanceInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FrameworkInstanceInfo_descriptor_,
      FrameworkInstanceInfo::default_instance_,
      FrameworkInstanceInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkInstanceInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkInstanceInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FrameworkInstanceInfo));
  FrameworkResourceInfo_descriptor_ = file->message_type(3);
  static const int FrameworkResourceInfo_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkResourceInfo, framework_instance_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkResourceInfo, resource_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkResourceInfo, module_pid_),
  };
  FrameworkResourceInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FrameworkResourceInfo_descriptor_,
      FrameworkResourceInfo::default_instance_,
      FrameworkResourceInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkResourceInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkResourceInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FrameworkResourceInfo));
  DockerImageInfo_descriptor_ = file->message_type(4);
  static const int DockerImageInfo_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DockerImageInfo, tag_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DockerImageInfo, locate_file_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DockerImageInfo, module_name_),
  };
  DockerImageInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DockerImageInfo_descriptor_,
      DockerImageInfo::default_instance_,
      DockerImageInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DockerImageInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DockerImageInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DockerImageInfo));
  NetAddress_descriptor_ = file->message_type(5);
  static const int NetAddress_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetAddress, ip_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetAddress, port_),
  };
  NetAddress_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      NetAddress_descriptor_,
      NetAddress::default_instance_,
      NetAddress_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetAddress, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetAddress, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(NetAddress));
  StartSlave_descriptor_ = file->message_type(6);
  static const int StartSlave_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StartSlave, framework_instance_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StartSlave, docker_image_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StartSlave, resource_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StartSlave, listen_port_num_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StartSlave, fm_master_net_address_),
  };
  StartSlave_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      StartSlave_descriptor_,
      StartSlave::default_instance_,
      StartSlave_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StartSlave, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StartSlave, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(StartSlave));
  RespondStartSlave_descriptor_ = file->message_type(7);
  static const int RespondStartSlave_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RespondStartSlave, framework_instance_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RespondStartSlave, machine_ip_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RespondStartSlave, module_pid_),
  };
  RespondStartSlave_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RespondStartSlave_descriptor_,
      RespondStartSlave::default_instance_,
      RespondStartSlave_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RespondStartSlave, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RespondStartSlave, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RespondStartSlave));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_FwmNcProtocol_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GpuResourceInfo_descriptor_, &GpuResourceInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ResourceInfo_descriptor_, &ResourceInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FrameworkInstanceInfo_descriptor_, &FrameworkInstanceInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FrameworkResourceInfo_descriptor_, &FrameworkResourceInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DockerImageInfo_descriptor_, &DockerImageInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    NetAddress_descriptor_, &NetAddress::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    StartSlave_descriptor_, &StartSlave::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RespondStartSlave_descriptor_, &RespondStartSlave::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_FwmNcProtocol_2eproto() {
  delete GpuResourceInfo::default_instance_;
  delete GpuResourceInfo_reflection_;
  delete ResourceInfo::default_instance_;
  delete ResourceInfo_reflection_;
  delete FrameworkInstanceInfo::default_instance_;
  delete FrameworkInstanceInfo_reflection_;
  delete FrameworkResourceInfo::default_instance_;
  delete FrameworkResourceInfo_reflection_;
  delete DockerImageInfo::default_instance_;
  delete DockerImageInfo_reflection_;
  delete NetAddress::default_instance_;
  delete NetAddress_reflection_;
  delete StartSlave::default_instance_;
  delete StartSlave_reflection_;
  delete RespondStartSlave::default_instance_;
  delete RespondStartSlave_reflection_;
}

void protobuf_AddDesc_FwmNcProtocol_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\023FwmNcProtocol.proto\022\nFwmNcProto\"9\n\017Gpu"
    "ResourceInfo\022\020\n\010gpu_name\030\001 \002(\t\022\024\n\014gpu_me"
    "m_size\030\002 \001(\r\"~\n\014ResourceInfo\022\017\n\007cpu_num\030"
    "\001 \002(\001\022\024\n\014cpu_mem_size\030\002 \002(\r\022\017\n\007gpu_num\030\003"
    " \001(\r\0226\n\021gpu_resource_info\030\004 \003(\0132\033.FwmNcP"
    "roto.GpuResourceInfo\"L\n\025FrameworkInstanc"
    "eInfo\022\024\n\014framework_id\030\001 \002(\r\022\035\n\025framework"
    "_instance_id\030\002 \002(\r\"\240\001\n\025FrameworkResource"
    "Info\022B\n\027framework_instance_info\030\001 \002(\0132!."
    "FwmNcProto.FrameworkInstanceInfo\022/\n\rreso"
    "urce_info\030\002 \001(\0132\030.FwmNcProto.ResourceInf"
    "o\022\022\n\nmodule_PID\030\003 \001(\r\"H\n\017DockerImageInfo"
    "\022\013\n\003tag\030\001 \002(\t\022\023\n\013locate_file\030\002 \001(\t\022\023\n\013mo"
    "dule_name\030\003 \001(\t\"&\n\nNetAddress\022\n\n\002ip\030\001 \002("
    "\t\022\014\n\004port\030\002 \001(\r\"\211\002\n\nStartSlave\022B\n\027framew"
    "ork_instance_info\030\001 \002(\0132!.FwmNcProto.Fra"
    "meworkInstanceInfo\0226\n\021docker_image_info\030"
    "\002 \001(\0132\033.FwmNcProto.DockerImageInfo\022/\n\rre"
    "source_info\030\003 \001(\0132\030.FwmNcProto.ResourceI"
    "nfo\022\027\n\017listen_port_num\030\004 \001(\r\0225\n\025FM_maste"
    "r_net_address\030\005 \001(\0132\026.FwmNcProto.NetAddr"
    "ess\"\177\n\021RespondStartSlave\022B\n\027framework_in"
    "stance_info\030\001 \002(\0132!.FwmNcProto.Framework"
    "InstanceInfo\022\022\n\nmachine_ip\030\002 \001(\t\022\022\n\nmodu"
    "le_PID\030\003 \001(\r", 972);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "FwmNcProtocol.proto", &protobuf_RegisterTypes);
  GpuResourceInfo::default_instance_ = new GpuResourceInfo();
  ResourceInfo::default_instance_ = new ResourceInfo();
  FrameworkInstanceInfo::default_instance_ = new FrameworkInstanceInfo();
  FrameworkResourceInfo::default_instance_ = new FrameworkResourceInfo();
  DockerImageInfo::default_instance_ = new DockerImageInfo();
  NetAddress::default_instance_ = new NetAddress();
  StartSlave::default_instance_ = new StartSlave();
  RespondStartSlave::default_instance_ = new RespondStartSlave();
  GpuResourceInfo::default_instance_->InitAsDefaultInstance();
  ResourceInfo::default_instance_->InitAsDefaultInstance();
  FrameworkInstanceInfo::default_instance_->InitAsDefaultInstance();
  FrameworkResourceInfo::default_instance_->InitAsDefaultInstance();
  DockerImageInfo::default_instance_->InitAsDefaultInstance();
  NetAddress::default_instance_->InitAsDefaultInstance();
  StartSlave::default_instance_->InitAsDefaultInstance();
  RespondStartSlave::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_FwmNcProtocol_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_FwmNcProtocol_2eproto {
  StaticDescriptorInitializer_FwmNcProtocol_2eproto() {
    protobuf_AddDesc_FwmNcProtocol_2eproto();
  }
} static_descriptor_initializer_FwmNcProtocol_2eproto_;


// ===================================================================

#ifndef _MSC_VER
const int GpuResourceInfo::kGpuNameFieldNumber;
const int GpuResourceInfo::kGpuMemSizeFieldNumber;
#endif  // !_MSC_VER

GpuResourceInfo::GpuResourceInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GpuResourceInfo::InitAsDefaultInstance() {
}

GpuResourceInfo::GpuResourceInfo(const GpuResourceInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GpuResourceInfo::SharedCtor() {
  _cached_size_ = 0;
  gpu_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  gpu_mem_size_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GpuResourceInfo::~GpuResourceInfo() {
  SharedDtor();
}

void GpuResourceInfo::SharedDtor() {
  if (gpu_name_ != &::google::protobuf::internal::kEmptyString) {
    delete gpu_name_;
  }
  if (this != default_instance_) {
  }
}

void GpuResourceInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GpuResourceInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GpuResourceInfo_descriptor_;
}

const GpuResourceInfo& GpuResourceInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_FwmNcProtocol_2eproto();  return *default_instance_;
}

GpuResourceInfo* GpuResourceInfo::default_instance_ = NULL;

GpuResourceInfo* GpuResourceInfo::New() const {
  return new GpuResourceInfo;
}

void GpuResourceInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_gpu_name()) {
      if (gpu_name_ != &::google::protobuf::internal::kEmptyString) {
        gpu_name_->clear();
      }
    }
    gpu_mem_size_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GpuResourceInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string gpu_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_gpu_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->gpu_name().data(), this->gpu_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_gpu_mem_size;
        break;
      }
      
      // optional uint32 gpu_mem_size = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_gpu_mem_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &gpu_mem_size_)));
          set_has_gpu_mem_size();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GpuResourceInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string gpu_name = 1;
  if (has_gpu_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->gpu_name().data(), this->gpu_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->gpu_name(), output);
  }
  
  // optional uint32 gpu_mem_size = 2;
  if (has_gpu_mem_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->gpu_mem_size(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GpuResourceInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string gpu_name = 1;
  if (has_gpu_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->gpu_name().data(), this->gpu_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->gpu_name(), target);
  }
  
  // optional uint32 gpu_mem_size = 2;
  if (has_gpu_mem_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->gpu_mem_size(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GpuResourceInfo::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string gpu_name = 1;
    if (has_gpu_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->gpu_name());
    }
    
    // optional uint32 gpu_mem_size = 2;
    if (has_gpu_mem_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->gpu_mem_size());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GpuResourceInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GpuResourceInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GpuResourceInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GpuResourceInfo::MergeFrom(const GpuResourceInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_gpu_name()) {
      set_gpu_name(from.gpu_name());
    }
    if (from.has_gpu_mem_size()) {
      set_gpu_mem_size(from.gpu_mem_size());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GpuResourceInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GpuResourceInfo::CopyFrom(const GpuResourceInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GpuResourceInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void GpuResourceInfo::Swap(GpuResourceInfo* other) {
  if (other != this) {
    std::swap(gpu_name_, other->gpu_name_);
    std::swap(gpu_mem_size_, other->gpu_mem_size_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GpuResourceInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GpuResourceInfo_descriptor_;
  metadata.reflection = GpuResourceInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ResourceInfo::kCpuNumFieldNumber;
const int ResourceInfo::kCpuMemSizeFieldNumber;
const int ResourceInfo::kGpuNumFieldNumber;
const int ResourceInfo::kGpuResourceInfoFieldNumber;
#endif  // !_MSC_VER

ResourceInfo::ResourceInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ResourceInfo::InitAsDefaultInstance() {
}

ResourceInfo::ResourceInfo(const ResourceInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ResourceInfo::SharedCtor() {
  _cached_size_ = 0;
  cpu_num_ = 0;
  cpu_mem_size_ = 0u;
  gpu_num_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResourceInfo::~ResourceInfo() {
  SharedDtor();
}

void ResourceInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ResourceInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ResourceInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ResourceInfo_descriptor_;
}

const ResourceInfo& ResourceInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_FwmNcProtocol_2eproto();  return *default_instance_;
}

ResourceInfo* ResourceInfo::default_instance_ = NULL;

ResourceInfo* ResourceInfo::New() const {
  return new ResourceInfo;
}

void ResourceInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    cpu_num_ = 0;
    cpu_mem_size_ = 0u;
    gpu_num_ = 0u;
  }
  gpu_resource_info_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ResourceInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required double cpu_num = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &cpu_num_)));
          set_has_cpu_num();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_cpu_mem_size;
        break;
      }
      
      // required uint32 cpu_mem_size = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_cpu_mem_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cpu_mem_size_)));
          set_has_cpu_mem_size();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_gpu_num;
        break;
      }
      
      // optional uint32 gpu_num = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_gpu_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &gpu_num_)));
          set_has_gpu_num();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_gpu_resource_info;
        break;
      }
      
      // repeated .FwmNcProto.GpuResourceInfo gpu_resource_info = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_gpu_resource_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_gpu_resource_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_gpu_resource_info;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResourceInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required double cpu_num = 1;
  if (has_cpu_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->cpu_num(), output);
  }
  
  // required uint32 cpu_mem_size = 2;
  if (has_cpu_mem_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->cpu_mem_size(), output);
  }
  
  // optional uint32 gpu_num = 3;
  if (has_gpu_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->gpu_num(), output);
  }
  
  // repeated .FwmNcProto.GpuResourceInfo gpu_resource_info = 4;
  for (int i = 0; i < this->gpu_resource_info_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->gpu_resource_info(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ResourceInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required double cpu_num = 1;
  if (has_cpu_num()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->cpu_num(), target);
  }
  
  // required uint32 cpu_mem_size = 2;
  if (has_cpu_mem_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->cpu_mem_size(), target);
  }
  
  // optional uint32 gpu_num = 3;
  if (has_gpu_num()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->gpu_num(), target);
  }
  
  // repeated .FwmNcProto.GpuResourceInfo gpu_resource_info = 4;
  for (int i = 0; i < this->gpu_resource_info_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->gpu_resource_info(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ResourceInfo::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required double cpu_num = 1;
    if (has_cpu_num()) {
      total_size += 1 + 8;
    }
    
    // required uint32 cpu_mem_size = 2;
    if (has_cpu_mem_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->cpu_mem_size());
    }
    
    // optional uint32 gpu_num = 3;
    if (has_gpu_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->gpu_num());
    }
    
  }
  // repeated .FwmNcProto.GpuResourceInfo gpu_resource_info = 4;
  total_size += 1 * this->gpu_resource_info_size();
  for (int i = 0; i < this->gpu_resource_info_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->gpu_resource_info(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResourceInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ResourceInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ResourceInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ResourceInfo::MergeFrom(const ResourceInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  gpu_resource_info_.MergeFrom(from.gpu_resource_info_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_cpu_num()) {
      set_cpu_num(from.cpu_num());
    }
    if (from.has_cpu_mem_size()) {
      set_cpu_mem_size(from.cpu_mem_size());
    }
    if (from.has_gpu_num()) {
      set_gpu_num(from.gpu_num());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ResourceInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ResourceInfo::CopyFrom(const ResourceInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResourceInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  for (int i = 0; i < gpu_resource_info_size(); i++) {
    if (!this->gpu_resource_info(i).IsInitialized()) return false;
  }
  return true;
}

void ResourceInfo::Swap(ResourceInfo* other) {
  if (other != this) {
    std::swap(cpu_num_, other->cpu_num_);
    std::swap(cpu_mem_size_, other->cpu_mem_size_);
    std::swap(gpu_num_, other->gpu_num_);
    gpu_resource_info_.Swap(&other->gpu_resource_info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ResourceInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ResourceInfo_descriptor_;
  metadata.reflection = ResourceInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int FrameworkInstanceInfo::kFrameworkIdFieldNumber;
const int FrameworkInstanceInfo::kFrameworkInstanceIdFieldNumber;
#endif  // !_MSC_VER

FrameworkInstanceInfo::FrameworkInstanceInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void FrameworkInstanceInfo::InitAsDefaultInstance() {
}

FrameworkInstanceInfo::FrameworkInstanceInfo(const FrameworkInstanceInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void FrameworkInstanceInfo::SharedCtor() {
  _cached_size_ = 0;
  framework_id_ = 0u;
  framework_instance_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FrameworkInstanceInfo::~FrameworkInstanceInfo() {
  SharedDtor();
}

void FrameworkInstanceInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void FrameworkInstanceInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FrameworkInstanceInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FrameworkInstanceInfo_descriptor_;
}

const FrameworkInstanceInfo& FrameworkInstanceInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_FwmNcProtocol_2eproto();  return *default_instance_;
}

FrameworkInstanceInfo* FrameworkInstanceInfo::default_instance_ = NULL;

FrameworkInstanceInfo* FrameworkInstanceInfo::New() const {
  return new FrameworkInstanceInfo;
}

void FrameworkInstanceInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    framework_id_ = 0u;
    framework_instance_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FrameworkInstanceInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 framework_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &framework_id_)));
          set_has_framework_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_framework_instance_id;
        break;
      }
      
      // required uint32 framework_instance_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_framework_instance_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &framework_instance_id_)));
          set_has_framework_instance_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FrameworkInstanceInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 framework_id = 1;
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->framework_id(), output);
  }
  
  // required uint32 framework_instance_id = 2;
  if (has_framework_instance_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->framework_instance_id(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* FrameworkInstanceInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 framework_id = 1;
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->framework_id(), target);
  }
  
  // required uint32 framework_instance_id = 2;
  if (has_framework_instance_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->framework_instance_id(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int FrameworkInstanceInfo::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 framework_id = 1;
    if (has_framework_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->framework_id());
    }
    
    // required uint32 framework_instance_id = 2;
    if (has_framework_instance_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->framework_instance_id());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FrameworkInstanceInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FrameworkInstanceInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FrameworkInstanceInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FrameworkInstanceInfo::MergeFrom(const FrameworkInstanceInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_framework_id()) {
      set_framework_id(from.framework_id());
    }
    if (from.has_framework_instance_id()) {
      set_framework_instance_id(from.framework_instance_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FrameworkInstanceInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FrameworkInstanceInfo::CopyFrom(const FrameworkInstanceInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FrameworkInstanceInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void FrameworkInstanceInfo::Swap(FrameworkInstanceInfo* other) {
  if (other != this) {
    std::swap(framework_id_, other->framework_id_);
    std::swap(framework_instance_id_, other->framework_instance_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FrameworkInstanceInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FrameworkInstanceInfo_descriptor_;
  metadata.reflection = FrameworkInstanceInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int FrameworkResourceInfo::kFrameworkInstanceInfoFieldNumber;
const int FrameworkResourceInfo::kResourceInfoFieldNumber;
const int FrameworkResourceInfo::kModulePIDFieldNumber;
#endif  // !_MSC_VER

FrameworkResourceInfo::FrameworkResourceInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void FrameworkResourceInfo::InitAsDefaultInstance() {
  framework_instance_info_ = const_cast< ::FwmNcProto::FrameworkInstanceInfo*>(&::FwmNcProto::FrameworkInstanceInfo::default_instance());
  resource_info_ = const_cast< ::FwmNcProto::ResourceInfo*>(&::FwmNcProto::ResourceInfo::default_instance());
}

FrameworkResourceInfo::FrameworkResourceInfo(const FrameworkResourceInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void FrameworkResourceInfo::SharedCtor() {
  _cached_size_ = 0;
  framework_instance_info_ = NULL;
  resource_info_ = NULL;
  module_pid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FrameworkResourceInfo::~FrameworkResourceInfo() {
  SharedDtor();
}

void FrameworkResourceInfo::SharedDtor() {
  if (this != default_instance_) {
    delete framework_instance_info_;
    delete resource_info_;
  }
}

void FrameworkResourceInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FrameworkResourceInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FrameworkResourceInfo_descriptor_;
}

const FrameworkResourceInfo& FrameworkResourceInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_FwmNcProtocol_2eproto();  return *default_instance_;
}

FrameworkResourceInfo* FrameworkResourceInfo::default_instance_ = NULL;

FrameworkResourceInfo* FrameworkResourceInfo::New() const {
  return new FrameworkResourceInfo;
}

void FrameworkResourceInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_framework_instance_info()) {
      if (framework_instance_info_ != NULL) framework_instance_info_->::FwmNcProto::FrameworkInstanceInfo::Clear();
    }
    if (has_resource_info()) {
      if (resource_info_ != NULL) resource_info_->::FwmNcProto::ResourceInfo::Clear();
    }
    module_pid_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FrameworkResourceInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .FwmNcProto.FrameworkInstanceInfo framework_instance_info = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_instance_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_resource_info;
        break;
      }
      
      // optional .FwmNcProto.ResourceInfo resource_info = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_resource_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_resource_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_module_PID;
        break;
      }
      
      // optional uint32 module_PID = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_module_PID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &module_pid_)));
          set_has_module_pid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FrameworkResourceInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .FwmNcProto.FrameworkInstanceInfo framework_instance_info = 1;
  if (has_framework_instance_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->framework_instance_info(), output);
  }
  
  // optional .FwmNcProto.ResourceInfo resource_info = 2;
  if (has_resource_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->resource_info(), output);
  }
  
  // optional uint32 module_PID = 3;
  if (has_module_pid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->module_pid(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* FrameworkResourceInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .FwmNcProto.FrameworkInstanceInfo framework_instance_info = 1;
  if (has_framework_instance_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->framework_instance_info(), target);
  }
  
  // optional .FwmNcProto.ResourceInfo resource_info = 2;
  if (has_resource_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->resource_info(), target);
  }
  
  // optional uint32 module_PID = 3;
  if (has_module_pid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->module_pid(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int FrameworkResourceInfo::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .FwmNcProto.FrameworkInstanceInfo framework_instance_info = 1;
    if (has_framework_instance_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_instance_info());
    }
    
    // optional .FwmNcProto.ResourceInfo resource_info = 2;
    if (has_resource_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->resource_info());
    }
    
    // optional uint32 module_PID = 3;
    if (has_module_pid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->module_pid());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FrameworkResourceInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FrameworkResourceInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FrameworkResourceInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FrameworkResourceInfo::MergeFrom(const FrameworkResourceInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_framework_instance_info()) {
      mutable_framework_instance_info()->::FwmNcProto::FrameworkInstanceInfo::MergeFrom(from.framework_instance_info());
    }
    if (from.has_resource_info()) {
      mutable_resource_info()->::FwmNcProto::ResourceInfo::MergeFrom(from.resource_info());
    }
    if (from.has_module_pid()) {
      set_module_pid(from.module_pid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FrameworkResourceInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FrameworkResourceInfo::CopyFrom(const FrameworkResourceInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FrameworkResourceInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_framework_instance_info()) {
    if (!this->framework_instance_info().IsInitialized()) return false;
  }
  if (has_resource_info()) {
    if (!this->resource_info().IsInitialized()) return false;
  }
  return true;
}

void FrameworkResourceInfo::Swap(FrameworkResourceInfo* other) {
  if (other != this) {
    std::swap(framework_instance_info_, other->framework_instance_info_);
    std::swap(resource_info_, other->resource_info_);
    std::swap(module_pid_, other->module_pid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FrameworkResourceInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FrameworkResourceInfo_descriptor_;
  metadata.reflection = FrameworkResourceInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int DockerImageInfo::kTagFieldNumber;
const int DockerImageInfo::kLocateFileFieldNumber;
const int DockerImageInfo::kModuleNameFieldNumber;
#endif  // !_MSC_VER

DockerImageInfo::DockerImageInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void DockerImageInfo::InitAsDefaultInstance() {
}

DockerImageInfo::DockerImageInfo(const DockerImageInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void DockerImageInfo::SharedCtor() {
  _cached_size_ = 0;
  tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  locate_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  module_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DockerImageInfo::~DockerImageInfo() {
  SharedDtor();
}

void DockerImageInfo::SharedDtor() {
  if (tag_ != &::google::protobuf::internal::kEmptyString) {
    delete tag_;
  }
  if (locate_file_ != &::google::protobuf::internal::kEmptyString) {
    delete locate_file_;
  }
  if (module_name_ != &::google::protobuf::internal::kEmptyString) {
    delete module_name_;
  }
  if (this != default_instance_) {
  }
}

void DockerImageInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DockerImageInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DockerImageInfo_descriptor_;
}

const DockerImageInfo& DockerImageInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_FwmNcProtocol_2eproto();  return *default_instance_;
}

DockerImageInfo* DockerImageInfo::default_instance_ = NULL;

DockerImageInfo* DockerImageInfo::New() const {
  return new DockerImageInfo;
}

void DockerImageInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_tag()) {
      if (tag_ != &::google::protobuf::internal::kEmptyString) {
        tag_->clear();
      }
    }
    if (has_locate_file()) {
      if (locate_file_ != &::google::protobuf::internal::kEmptyString) {
        locate_file_->clear();
      }
    }
    if (has_module_name()) {
      if (module_name_ != &::google::protobuf::internal::kEmptyString) {
        module_name_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DockerImageInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string tag = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_tag()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->tag().data(), this->tag().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_locate_file;
        break;
      }
      
      // optional string locate_file = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_locate_file:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_locate_file()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->locate_file().data(), this->locate_file().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_module_name;
        break;
      }
      
      // optional string module_name = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_module_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_module_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->module_name().data(), this->module_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DockerImageInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string tag = 1;
  if (has_tag()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->tag().data(), this->tag().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->tag(), output);
  }
  
  // optional string locate_file = 2;
  if (has_locate_file()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->locate_file().data(), this->locate_file().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->locate_file(), output);
  }
  
  // optional string module_name = 3;
  if (has_module_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->module_name().data(), this->module_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->module_name(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* DockerImageInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string tag = 1;
  if (has_tag()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->tag().data(), this->tag().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->tag(), target);
  }
  
  // optional string locate_file = 2;
  if (has_locate_file()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->locate_file().data(), this->locate_file().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->locate_file(), target);
  }
  
  // optional string module_name = 3;
  if (has_module_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->module_name().data(), this->module_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->module_name(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int DockerImageInfo::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string tag = 1;
    if (has_tag()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->tag());
    }
    
    // optional string locate_file = 2;
    if (has_locate_file()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->locate_file());
    }
    
    // optional string module_name = 3;
    if (has_module_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->module_name());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DockerImageInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DockerImageInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DockerImageInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DockerImageInfo::MergeFrom(const DockerImageInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_tag()) {
      set_tag(from.tag());
    }
    if (from.has_locate_file()) {
      set_locate_file(from.locate_file());
    }
    if (from.has_module_name()) {
      set_module_name(from.module_name());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DockerImageInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DockerImageInfo::CopyFrom(const DockerImageInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DockerImageInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void DockerImageInfo::Swap(DockerImageInfo* other) {
  if (other != this) {
    std::swap(tag_, other->tag_);
    std::swap(locate_file_, other->locate_file_);
    std::swap(module_name_, other->module_name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DockerImageInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DockerImageInfo_descriptor_;
  metadata.reflection = DockerImageInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int NetAddress::kIpFieldNumber;
const int NetAddress::kPortFieldNumber;
#endif  // !_MSC_VER

NetAddress::NetAddress()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void NetAddress::InitAsDefaultInstance() {
}

NetAddress::NetAddress(const NetAddress& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void NetAddress::SharedCtor() {
  _cached_size_ = 0;
  ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  port_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NetAddress::~NetAddress() {
  SharedDtor();
}

void NetAddress::SharedDtor() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (this != default_instance_) {
  }
}

void NetAddress::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NetAddress::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NetAddress_descriptor_;
}

const NetAddress& NetAddress::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_FwmNcProtocol_2eproto();  return *default_instance_;
}

NetAddress* NetAddress::default_instance_ = NULL;

NetAddress* NetAddress::New() const {
  return new NetAddress;
}

void NetAddress::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_ip()) {
      if (ip_ != &::google::protobuf::internal::kEmptyString) {
        ip_->clear();
      }
    }
    port_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool NetAddress::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string ip = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ip()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->ip().data(), this->ip().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_port;
        break;
      }
      
      // optional uint32 port = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &port_)));
          set_has_port();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NetAddress::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string ip = 1;
  if (has_ip()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->ip().data(), this->ip().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->ip(), output);
  }
  
  // optional uint32 port = 2;
  if (has_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->port(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* NetAddress::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string ip = 1;
  if (has_ip()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->ip().data(), this->ip().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->ip(), target);
  }
  
  // optional uint32 port = 2;
  if (has_port()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->port(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int NetAddress::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string ip = 1;
    if (has_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ip());
    }
    
    // optional uint32 port = 2;
    if (has_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->port());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NetAddress::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const NetAddress* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const NetAddress*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NetAddress::MergeFrom(const NetAddress& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ip()) {
      set_ip(from.ip());
    }
    if (from.has_port()) {
      set_port(from.port());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void NetAddress::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NetAddress::CopyFrom(const NetAddress& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NetAddress::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void NetAddress::Swap(NetAddress* other) {
  if (other != this) {
    std::swap(ip_, other->ip_);
    std::swap(port_, other->port_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata NetAddress::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NetAddress_descriptor_;
  metadata.reflection = NetAddress_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int StartSlave::kFrameworkInstanceInfoFieldNumber;
const int StartSlave::kDockerImageInfoFieldNumber;
const int StartSlave::kResourceInfoFieldNumber;
const int StartSlave::kListenPortNumFieldNumber;
const int StartSlave::kFMMasterNetAddressFieldNumber;
#endif  // !_MSC_VER

StartSlave::StartSlave()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void StartSlave::InitAsDefaultInstance() {
  framework_instance_info_ = const_cast< ::FwmNcProto::FrameworkInstanceInfo*>(&::FwmNcProto::FrameworkInstanceInfo::default_instance());
  docker_image_info_ = const_cast< ::FwmNcProto::DockerImageInfo*>(&::FwmNcProto::DockerImageInfo::default_instance());
  resource_info_ = const_cast< ::FwmNcProto::ResourceInfo*>(&::FwmNcProto::ResourceInfo::default_instance());
  fm_master_net_address_ = const_cast< ::FwmNcProto::NetAddress*>(&::FwmNcProto::NetAddress::default_instance());
}

StartSlave::StartSlave(const StartSlave& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void StartSlave::SharedCtor() {
  _cached_size_ = 0;
  framework_instance_info_ = NULL;
  docker_image_info_ = NULL;
  resource_info_ = NULL;
  listen_port_num_ = 0u;
  fm_master_net_address_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StartSlave::~StartSlave() {
  SharedDtor();
}

void StartSlave::SharedDtor() {
  if (this != default_instance_) {
    delete framework_instance_info_;
    delete docker_image_info_;
    delete resource_info_;
    delete fm_master_net_address_;
  }
}

void StartSlave::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* StartSlave::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return StartSlave_descriptor_;
}

const StartSlave& StartSlave::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_FwmNcProtocol_2eproto();  return *default_instance_;
}

StartSlave* StartSlave::default_instance_ = NULL;

StartSlave* StartSlave::New() const {
  return new StartSlave;
}

void StartSlave::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_framework_instance_info()) {
      if (framework_instance_info_ != NULL) framework_instance_info_->::FwmNcProto::FrameworkInstanceInfo::Clear();
    }
    if (has_docker_image_info()) {
      if (docker_image_info_ != NULL) docker_image_info_->::FwmNcProto::DockerImageInfo::Clear();
    }
    if (has_resource_info()) {
      if (resource_info_ != NULL) resource_info_->::FwmNcProto::ResourceInfo::Clear();
    }
    listen_port_num_ = 0u;
    if (has_fm_master_net_address()) {
      if (fm_master_net_address_ != NULL) fm_master_net_address_->::FwmNcProto::NetAddress::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool StartSlave::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .FwmNcProto.FrameworkInstanceInfo framework_instance_info = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_instance_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_docker_image_info;
        break;
      }
      
      // optional .FwmNcProto.DockerImageInfo docker_image_info = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_docker_image_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_docker_image_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_resource_info;
        break;
      }
      
      // optional .FwmNcProto.ResourceInfo resource_info = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_resource_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_resource_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_listen_port_num;
        break;
      }
      
      // optional uint32 listen_port_num = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_listen_port_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &listen_port_num_)));
          set_has_listen_port_num();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_FM_master_net_address;
        break;
      }
      
      // optional .FwmNcProto.NetAddress FM_master_net_address = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_FM_master_net_address:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_fm_master_net_address()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void StartSlave::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .FwmNcProto.FrameworkInstanceInfo framework_instance_info = 1;
  if (has_framework_instance_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->framework_instance_info(), output);
  }
  
  // optional .FwmNcProto.DockerImageInfo docker_image_info = 2;
  if (has_docker_image_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->docker_image_info(), output);
  }
  
  // optional .FwmNcProto.ResourceInfo resource_info = 3;
  if (has_resource_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->resource_info(), output);
  }
  
  // optional uint32 listen_port_num = 4;
  if (has_listen_port_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->listen_port_num(), output);
  }
  
  // optional .FwmNcProto.NetAddress FM_master_net_address = 5;
  if (has_fm_master_net_address()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->fm_master_net_address(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* StartSlave::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .FwmNcProto.FrameworkInstanceInfo framework_instance_info = 1;
  if (has_framework_instance_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->framework_instance_info(), target);
  }
  
  // optional .FwmNcProto.DockerImageInfo docker_image_info = 2;
  if (has_docker_image_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->docker_image_info(), target);
  }
  
  // optional .FwmNcProto.ResourceInfo resource_info = 3;
  if (has_resource_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->resource_info(), target);
  }
  
  // optional uint32 listen_port_num = 4;
  if (has_listen_port_num()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->listen_port_num(), target);
  }
  
  // optional .FwmNcProto.NetAddress FM_master_net_address = 5;
  if (has_fm_master_net_address()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->fm_master_net_address(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int StartSlave::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .FwmNcProto.FrameworkInstanceInfo framework_instance_info = 1;
    if (has_framework_instance_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_instance_info());
    }
    
    // optional .FwmNcProto.DockerImageInfo docker_image_info = 2;
    if (has_docker_image_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->docker_image_info());
    }
    
    // optional .FwmNcProto.ResourceInfo resource_info = 3;
    if (has_resource_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->resource_info());
    }
    
    // optional uint32 listen_port_num = 4;
    if (has_listen_port_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->listen_port_num());
    }
    
    // optional .FwmNcProto.NetAddress FM_master_net_address = 5;
    if (has_fm_master_net_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->fm_master_net_address());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StartSlave::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const StartSlave* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const StartSlave*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void StartSlave::MergeFrom(const StartSlave& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_framework_instance_info()) {
      mutable_framework_instance_info()->::FwmNcProto::FrameworkInstanceInfo::MergeFrom(from.framework_instance_info());
    }
    if (from.has_docker_image_info()) {
      mutable_docker_image_info()->::FwmNcProto::DockerImageInfo::MergeFrom(from.docker_image_info());
    }
    if (from.has_resource_info()) {
      mutable_resource_info()->::FwmNcProto::ResourceInfo::MergeFrom(from.resource_info());
    }
    if (from.has_listen_port_num()) {
      set_listen_port_num(from.listen_port_num());
    }
    if (from.has_fm_master_net_address()) {
      mutable_fm_master_net_address()->::FwmNcProto::NetAddress::MergeFrom(from.fm_master_net_address());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void StartSlave::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StartSlave::CopyFrom(const StartSlave& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StartSlave::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_framework_instance_info()) {
    if (!this->framework_instance_info().IsInitialized()) return false;
  }
  if (has_docker_image_info()) {
    if (!this->docker_image_info().IsInitialized()) return false;
  }
  if (has_resource_info()) {
    if (!this->resource_info().IsInitialized()) return false;
  }
  if (has_fm_master_net_address()) {
    if (!this->fm_master_net_address().IsInitialized()) return false;
  }
  return true;
}

void StartSlave::Swap(StartSlave* other) {
  if (other != this) {
    std::swap(framework_instance_info_, other->framework_instance_info_);
    std::swap(docker_image_info_, other->docker_image_info_);
    std::swap(resource_info_, other->resource_info_);
    std::swap(listen_port_num_, other->listen_port_num_);
    std::swap(fm_master_net_address_, other->fm_master_net_address_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata StartSlave::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = StartSlave_descriptor_;
  metadata.reflection = StartSlave_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RespondStartSlave::kFrameworkInstanceInfoFieldNumber;
const int RespondStartSlave::kMachineIpFieldNumber;
const int RespondStartSlave::kModulePIDFieldNumber;
#endif  // !_MSC_VER

RespondStartSlave::RespondStartSlave()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void RespondStartSlave::InitAsDefaultInstance() {
  framework_instance_info_ = const_cast< ::FwmNcProto::FrameworkInstanceInfo*>(&::FwmNcProto::FrameworkInstanceInfo::default_instance());
}

RespondStartSlave::RespondStartSlave(const RespondStartSlave& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void RespondStartSlave::SharedCtor() {
  _cached_size_ = 0;
  framework_instance_info_ = NULL;
  machine_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  module_pid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RespondStartSlave::~RespondStartSlave() {
  SharedDtor();
}

void RespondStartSlave::SharedDtor() {
  if (machine_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete machine_ip_;
  }
  if (this != default_instance_) {
    delete framework_instance_info_;
  }
}

void RespondStartSlave::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RespondStartSlave::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RespondStartSlave_descriptor_;
}

const RespondStartSlave& RespondStartSlave::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_FwmNcProtocol_2eproto();  return *default_instance_;
}

RespondStartSlave* RespondStartSlave::default_instance_ = NULL;

RespondStartSlave* RespondStartSlave::New() const {
  return new RespondStartSlave;
}

void RespondStartSlave::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_framework_instance_info()) {
      if (framework_instance_info_ != NULL) framework_instance_info_->::FwmNcProto::FrameworkInstanceInfo::Clear();
    }
    if (has_machine_ip()) {
      if (machine_ip_ != &::google::protobuf::internal::kEmptyString) {
        machine_ip_->clear();
      }
    }
    module_pid_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RespondStartSlave::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .FwmNcProto.FrameworkInstanceInfo framework_instance_info = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_instance_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_machine_ip;
        break;
      }
      
      // optional string machine_ip = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_machine_ip:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_machine_ip()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->machine_ip().data(), this->machine_ip().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_module_PID;
        break;
      }
      
      // optional uint32 module_PID = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_module_PID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &module_pid_)));
          set_has_module_pid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RespondStartSlave::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .FwmNcProto.FrameworkInstanceInfo framework_instance_info = 1;
  if (has_framework_instance_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->framework_instance_info(), output);
  }
  
  // optional string machine_ip = 2;
  if (has_machine_ip()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->machine_ip().data(), this->machine_ip().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->machine_ip(), output);
  }
  
  // optional uint32 module_PID = 3;
  if (has_module_pid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->module_pid(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* RespondStartSlave::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .FwmNcProto.FrameworkInstanceInfo framework_instance_info = 1;
  if (has_framework_instance_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->framework_instance_info(), target);
  }
  
  // optional string machine_ip = 2;
  if (has_machine_ip()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->machine_ip().data(), this->machine_ip().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->machine_ip(), target);
  }
  
  // optional uint32 module_PID = 3;
  if (has_module_pid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->module_pid(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int RespondStartSlave::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .FwmNcProto.FrameworkInstanceInfo framework_instance_info = 1;
    if (has_framework_instance_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_instance_info());
    }
    
    // optional string machine_ip = 2;
    if (has_machine_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->machine_ip());
    }
    
    // optional uint32 module_PID = 3;
    if (has_module_pid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->module_pid());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RespondStartSlave::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RespondStartSlave* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RespondStartSlave*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RespondStartSlave::MergeFrom(const RespondStartSlave& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_framework_instance_info()) {
      mutable_framework_instance_info()->::FwmNcProto::FrameworkInstanceInfo::MergeFrom(from.framework_instance_info());
    }
    if (from.has_machine_ip()) {
      set_machine_ip(from.machine_ip());
    }
    if (from.has_module_pid()) {
      set_module_pid(from.module_pid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RespondStartSlave::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RespondStartSlave::CopyFrom(const RespondStartSlave& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RespondStartSlave::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_framework_instance_info()) {
    if (!this->framework_instance_info().IsInitialized()) return false;
  }
  return true;
}

void RespondStartSlave::Swap(RespondStartSlave* other) {
  if (other != this) {
    std::swap(framework_instance_info_, other->framework_instance_info_);
    std::swap(machine_ip_, other->machine_ip_);
    std::swap(module_pid_, other->module_pid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RespondStartSlave::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RespondStartSlave_descriptor_;
  metadata.reflection = RespondStartSlave_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace FwmNcProto

// @@protoc_insertion_point(global_scope)
