// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ALProtocol.proto

#ifndef PROTOBUF_ALProtocol_2eproto__INCLUDED
#define PROTOBUF_ALProtocol_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace alproto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ALProtocol_2eproto();
void protobuf_AssignDesc_ALProtocol_2eproto();
void protobuf_ShutdownFile_ALProtocol_2eproto();

class GpuResourceInfo;
class ResourceInfo;
class FrameworkIDInfo;
class FrameworkInstanceInfo;
class StartRootModule;
class AssignResourceInfo;
class ActualResourceInfo;
class AssignAndActualResourceInfo;
class PlatformAndMachineResouceInfo;
class ApplyAndUseResourceInfo;
class MachineInstanceResourceInfo;
class InstanceMachineResourceInfo;
class FrameworkInstanceResourceInfo;
class NetworkAddress;

// ===================================================================

class GpuResourceInfo : public ::google::protobuf::Message {
 public:
  GpuResourceInfo();
  virtual ~GpuResourceInfo();
  
  GpuResourceInfo(const GpuResourceInfo& from);
  
  inline GpuResourceInfo& operator=(const GpuResourceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GpuResourceInfo& default_instance();
  
  void Swap(GpuResourceInfo* other);
  
  // implements Message ----------------------------------------------
  
  GpuResourceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GpuResourceInfo& from);
  void MergeFrom(const GpuResourceInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string gpu_name = 1;
  inline bool has_gpu_name() const;
  inline void clear_gpu_name();
  static const int kGpuNameFieldNumber = 1;
  inline const ::std::string& gpu_name() const;
  inline void set_gpu_name(const ::std::string& value);
  inline void set_gpu_name(const char* value);
  inline void set_gpu_name(const char* value, size_t size);
  inline ::std::string* mutable_gpu_name();
  inline ::std::string* release_gpu_name();
  
  // optional uint32 gpu_mem_size = 2;
  inline bool has_gpu_mem_size() const;
  inline void clear_gpu_mem_size();
  static const int kGpuMemSizeFieldNumber = 2;
  inline ::google::protobuf::uint32 gpu_mem_size() const;
  inline void set_gpu_mem_size(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:alproto.GpuResourceInfo)
 private:
  inline void set_has_gpu_name();
  inline void clear_has_gpu_name();
  inline void set_has_gpu_mem_size();
  inline void clear_has_gpu_mem_size();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* gpu_name_;
  ::google::protobuf::uint32 gpu_mem_size_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ALProtocol_2eproto();
  friend void protobuf_AssignDesc_ALProtocol_2eproto();
  friend void protobuf_ShutdownFile_ALProtocol_2eproto();
  
  void InitAsDefaultInstance();
  static GpuResourceInfo* default_instance_;
};
// -------------------------------------------------------------------

class ResourceInfo : public ::google::protobuf::Message {
 public:
  ResourceInfo();
  virtual ~ResourceInfo();
  
  ResourceInfo(const ResourceInfo& from);
  
  inline ResourceInfo& operator=(const ResourceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResourceInfo& default_instance();
  
  void Swap(ResourceInfo* other);
  
  // implements Message ----------------------------------------------
  
  ResourceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResourceInfo& from);
  void MergeFrom(const ResourceInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required double cpu_num = 1;
  inline bool has_cpu_num() const;
  inline void clear_cpu_num();
  static const int kCpuNumFieldNumber = 1;
  inline double cpu_num() const;
  inline void set_cpu_num(double value);
  
  // required uint32 cpu_mem_size = 2;
  inline bool has_cpu_mem_size() const;
  inline void clear_cpu_mem_size();
  static const int kCpuMemSizeFieldNumber = 2;
  inline ::google::protobuf::uint32 cpu_mem_size() const;
  inline void set_cpu_mem_size(::google::protobuf::uint32 value);
  
  // optional uint32 gpu_num = 3;
  inline bool has_gpu_num() const;
  inline void clear_gpu_num();
  static const int kGpuNumFieldNumber = 3;
  inline ::google::protobuf::uint32 gpu_num() const;
  inline void set_gpu_num(::google::protobuf::uint32 value);
  
  // repeated .alproto.GpuResourceInfo gpu_resource_info = 4;
  inline int gpu_resource_info_size() const;
  inline void clear_gpu_resource_info();
  static const int kGpuResourceInfoFieldNumber = 4;
  inline const ::alproto::GpuResourceInfo& gpu_resource_info(int index) const;
  inline ::alproto::GpuResourceInfo* mutable_gpu_resource_info(int index);
  inline ::alproto::GpuResourceInfo* add_gpu_resource_info();
  inline const ::google::protobuf::RepeatedPtrField< ::alproto::GpuResourceInfo >&
      gpu_resource_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::alproto::GpuResourceInfo >*
      mutable_gpu_resource_info();
  
  // @@protoc_insertion_point(class_scope:alproto.ResourceInfo)
 private:
  inline void set_has_cpu_num();
  inline void clear_has_cpu_num();
  inline void set_has_cpu_mem_size();
  inline void clear_has_cpu_mem_size();
  inline void set_has_gpu_num();
  inline void clear_has_gpu_num();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  double cpu_num_;
  ::google::protobuf::uint32 cpu_mem_size_;
  ::google::protobuf::uint32 gpu_num_;
  ::google::protobuf::RepeatedPtrField< ::alproto::GpuResourceInfo > gpu_resource_info_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_ALProtocol_2eproto();
  friend void protobuf_AssignDesc_ALProtocol_2eproto();
  friend void protobuf_ShutdownFile_ALProtocol_2eproto();
  
  void InitAsDefaultInstance();
  static ResourceInfo* default_instance_;
};
// -------------------------------------------------------------------

class FrameworkIDInfo : public ::google::protobuf::Message {
 public:
  FrameworkIDInfo();
  virtual ~FrameworkIDInfo();
  
  FrameworkIDInfo(const FrameworkIDInfo& from);
  
  inline FrameworkIDInfo& operator=(const FrameworkIDInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FrameworkIDInfo& default_instance();
  
  void Swap(FrameworkIDInfo* other);
  
  // implements Message ----------------------------------------------
  
  FrameworkIDInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FrameworkIDInfo& from);
  void MergeFrom(const FrameworkIDInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 framework_id = 1;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 1;
  inline ::google::protobuf::uint32 framework_id() const;
  inline void set_framework_id(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:alproto.FrameworkIDInfo)
 private:
  inline void set_has_framework_id();
  inline void clear_has_framework_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 framework_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_ALProtocol_2eproto();
  friend void protobuf_AssignDesc_ALProtocol_2eproto();
  friend void protobuf_ShutdownFile_ALProtocol_2eproto();
  
  void InitAsDefaultInstance();
  static FrameworkIDInfo* default_instance_;
};
// -------------------------------------------------------------------

class FrameworkInstanceInfo : public ::google::protobuf::Message {
 public:
  FrameworkInstanceInfo();
  virtual ~FrameworkInstanceInfo();
  
  FrameworkInstanceInfo(const FrameworkInstanceInfo& from);
  
  inline FrameworkInstanceInfo& operator=(const FrameworkInstanceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FrameworkInstanceInfo& default_instance();
  
  void Swap(FrameworkInstanceInfo* other);
  
  // implements Message ----------------------------------------------
  
  FrameworkInstanceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FrameworkInstanceInfo& from);
  void MergeFrom(const FrameworkInstanceInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 framework_id = 1;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 1;
  inline ::google::protobuf::uint32 framework_id() const;
  inline void set_framework_id(::google::protobuf::uint32 value);
  
  // required uint32 framework_instance_id = 2;
  inline bool has_framework_instance_id() const;
  inline void clear_framework_instance_id();
  static const int kFrameworkInstanceIdFieldNumber = 2;
  inline ::google::protobuf::uint32 framework_instance_id() const;
  inline void set_framework_instance_id(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:alproto.FrameworkInstanceInfo)
 private:
  inline void set_has_framework_id();
  inline void clear_has_framework_id();
  inline void set_has_framework_instance_id();
  inline void clear_has_framework_instance_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 framework_id_;
  ::google::protobuf::uint32 framework_instance_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ALProtocol_2eproto();
  friend void protobuf_AssignDesc_ALProtocol_2eproto();
  friend void protobuf_ShutdownFile_ALProtocol_2eproto();
  
  void InitAsDefaultInstance();
  static FrameworkInstanceInfo* default_instance_;
};
// -------------------------------------------------------------------

class StartRootModule : public ::google::protobuf::Message {
 public:
  StartRootModule();
  virtual ~StartRootModule();
  
  StartRootModule(const StartRootModule& from);
  
  inline StartRootModule& operator=(const StartRootModule& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StartRootModule& default_instance();
  
  void Swap(StartRootModule* other);
  
  // implements Message ----------------------------------------------
  
  StartRootModule* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StartRootModule& from);
  void MergeFrom(const StartRootModule& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 framework_id = 1;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 1;
  inline ::google::protobuf::uint32 framework_id() const;
  inline void set_framework_id(::google::protobuf::uint32 value);
  
  // optional string image_lable = 2;
  inline bool has_image_lable() const;
  inline void clear_image_lable();
  static const int kImageLableFieldNumber = 2;
  inline const ::std::string& image_lable() const;
  inline void set_image_lable(const ::std::string& value);
  inline void set_image_lable(const char* value);
  inline void set_image_lable(const char* value, size_t size);
  inline ::std::string* mutable_image_lable();
  inline ::std::string* release_image_lable();
  
  // optional string module_name = 3;
  inline bool has_module_name() const;
  inline void clear_module_name();
  static const int kModuleNameFieldNumber = 3;
  inline const ::std::string& module_name() const;
  inline void set_module_name(const ::std::string& value);
  inline void set_module_name(const char* value);
  inline void set_module_name(const char* value, size_t size);
  inline ::std::string* mutable_module_name();
  inline ::std::string* release_module_name();
  
  // optional string location_file_path = 4;
  inline bool has_location_file_path() const;
  inline void clear_location_file_path();
  static const int kLocationFilePathFieldNumber = 4;
  inline const ::std::string& location_file_path() const;
  inline void set_location_file_path(const ::std::string& value);
  inline void set_location_file_path(const char* value);
  inline void set_location_file_path(const char* value, size_t size);
  inline ::std::string* mutable_location_file_path();
  inline ::std::string* release_location_file_path();
  
  // repeated string nc_ip = 5;
  inline int nc_ip_size() const;
  inline void clear_nc_ip();
  static const int kNcIpFieldNumber = 5;
  inline const ::std::string& nc_ip(int index) const;
  inline ::std::string* mutable_nc_ip(int index);
  inline void set_nc_ip(int index, const ::std::string& value);
  inline void set_nc_ip(int index, const char* value);
  inline void set_nc_ip(int index, const char* value, size_t size);
  inline ::std::string* add_nc_ip();
  inline void add_nc_ip(const ::std::string& value);
  inline void add_nc_ip(const char* value);
  inline void add_nc_ip(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& nc_ip() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_nc_ip();
  
  // optional .alproto.ResourceInfo request_resource_size = 6;
  inline bool has_request_resource_size() const;
  inline void clear_request_resource_size();
  static const int kRequestResourceSizeFieldNumber = 6;
  inline const ::alproto::ResourceInfo& request_resource_size() const;
  inline ::alproto::ResourceInfo* mutable_request_resource_size();
  inline ::alproto::ResourceInfo* release_request_resource_size();
  
  // optional uint32 listen_num = 7;
  inline bool has_listen_num() const;
  inline void clear_listen_num();
  static const int kListenNumFieldNumber = 7;
  inline ::google::protobuf::uint32 listen_num() const;
  inline void set_listen_num(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:alproto.StartRootModule)
 private:
  inline void set_has_framework_id();
  inline void clear_has_framework_id();
  inline void set_has_image_lable();
  inline void clear_has_image_lable();
  inline void set_has_module_name();
  inline void clear_has_module_name();
  inline void set_has_location_file_path();
  inline void clear_has_location_file_path();
  inline void set_has_request_resource_size();
  inline void clear_has_request_resource_size();
  inline void set_has_listen_num();
  inline void clear_has_listen_num();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* image_lable_;
  ::std::string* module_name_;
  ::std::string* location_file_path_;
  ::google::protobuf::uint32 framework_id_;
  ::google::protobuf::uint32 listen_num_;
  ::google::protobuf::RepeatedPtrField< ::std::string> nc_ip_;
  ::alproto::ResourceInfo* request_resource_size_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_ALProtocol_2eproto();
  friend void protobuf_AssignDesc_ALProtocol_2eproto();
  friend void protobuf_ShutdownFile_ALProtocol_2eproto();
  
  void InitAsDefaultInstance();
  static StartRootModule* default_instance_;
};
// -------------------------------------------------------------------

class AssignResourceInfo : public ::google::protobuf::Message {
 public:
  AssignResourceInfo();
  virtual ~AssignResourceInfo();
  
  AssignResourceInfo(const AssignResourceInfo& from);
  
  inline AssignResourceInfo& operator=(const AssignResourceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AssignResourceInfo& default_instance();
  
  void Swap(AssignResourceInfo* other);
  
  // implements Message ----------------------------------------------
  
  AssignResourceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AssignResourceInfo& from);
  void MergeFrom(const AssignResourceInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .alproto.ResourceInfo total_have_resource = 1;
  inline bool has_total_have_resource() const;
  inline void clear_total_have_resource();
  static const int kTotalHaveResourceFieldNumber = 1;
  inline const ::alproto::ResourceInfo& total_have_resource() const;
  inline ::alproto::ResourceInfo* mutable_total_have_resource();
  inline ::alproto::ResourceInfo* release_total_have_resource();
  
  // optional .alproto.ResourceInfo total_not_assign_resource = 2;
  inline bool has_total_not_assign_resource() const;
  inline void clear_total_not_assign_resource();
  static const int kTotalNotAssignResourceFieldNumber = 2;
  inline const ::alproto::ResourceInfo& total_not_assign_resource() const;
  inline ::alproto::ResourceInfo* mutable_total_not_assign_resource();
  inline ::alproto::ResourceInfo* release_total_not_assign_resource();
  
  // optional .alproto.ResourceInfo total_already_assign_resource = 3;
  inline bool has_total_already_assign_resource() const;
  inline void clear_total_already_assign_resource();
  static const int kTotalAlreadyAssignResourceFieldNumber = 3;
  inline const ::alproto::ResourceInfo& total_already_assign_resource() const;
  inline ::alproto::ResourceInfo* mutable_total_already_assign_resource();
  inline ::alproto::ResourceInfo* release_total_already_assign_resource();
  
  // @@protoc_insertion_point(class_scope:alproto.AssignResourceInfo)
 private:
  inline void set_has_total_have_resource();
  inline void clear_has_total_have_resource();
  inline void set_has_total_not_assign_resource();
  inline void clear_has_total_not_assign_resource();
  inline void set_has_total_already_assign_resource();
  inline void clear_has_total_already_assign_resource();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::alproto::ResourceInfo* total_have_resource_;
  ::alproto::ResourceInfo* total_not_assign_resource_;
  ::alproto::ResourceInfo* total_already_assign_resource_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_ALProtocol_2eproto();
  friend void protobuf_AssignDesc_ALProtocol_2eproto();
  friend void protobuf_ShutdownFile_ALProtocol_2eproto();
  
  void InitAsDefaultInstance();
  static AssignResourceInfo* default_instance_;
};
// -------------------------------------------------------------------

class ActualResourceInfo : public ::google::protobuf::Message {
 public:
  ActualResourceInfo();
  virtual ~ActualResourceInfo();
  
  ActualResourceInfo(const ActualResourceInfo& from);
  
  inline ActualResourceInfo& operator=(const ActualResourceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ActualResourceInfo& default_instance();
  
  void Swap(ActualResourceInfo* other);
  
  // implements Message ----------------------------------------------
  
  ActualResourceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActualResourceInfo& from);
  void MergeFrom(const ActualResourceInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .alproto.ResourceInfo total_use_resource = 1;
  inline bool has_total_use_resource() const;
  inline void clear_total_use_resource();
  static const int kTotalUseResourceFieldNumber = 1;
  inline const ::alproto::ResourceInfo& total_use_resource() const;
  inline ::alproto::ResourceInfo* mutable_total_use_resource();
  inline ::alproto::ResourceInfo* release_total_use_resource();
  
  // optional .alproto.ResourceInfo total_not_use_resource = 2;
  inline bool has_total_not_use_resource() const;
  inline void clear_total_not_use_resource();
  static const int kTotalNotUseResourceFieldNumber = 2;
  inline const ::alproto::ResourceInfo& total_not_use_resource() const;
  inline ::alproto::ResourceInfo* mutable_total_not_use_resource();
  inline ::alproto::ResourceInfo* release_total_not_use_resource();
  
  // @@protoc_insertion_point(class_scope:alproto.ActualResourceInfo)
 private:
  inline void set_has_total_use_resource();
  inline void clear_has_total_use_resource();
  inline void set_has_total_not_use_resource();
  inline void clear_has_total_not_use_resource();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::alproto::ResourceInfo* total_use_resource_;
  ::alproto::ResourceInfo* total_not_use_resource_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ALProtocol_2eproto();
  friend void protobuf_AssignDesc_ALProtocol_2eproto();
  friend void protobuf_ShutdownFile_ALProtocol_2eproto();
  
  void InitAsDefaultInstance();
  static ActualResourceInfo* default_instance_;
};
// -------------------------------------------------------------------

class AssignAndActualResourceInfo : public ::google::protobuf::Message {
 public:
  AssignAndActualResourceInfo();
  virtual ~AssignAndActualResourceInfo();
  
  AssignAndActualResourceInfo(const AssignAndActualResourceInfo& from);
  
  inline AssignAndActualResourceInfo& operator=(const AssignAndActualResourceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AssignAndActualResourceInfo& default_instance();
  
  void Swap(AssignAndActualResourceInfo* other);
  
  // implements Message ----------------------------------------------
  
  AssignAndActualResourceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AssignAndActualResourceInfo& from);
  void MergeFrom(const AssignAndActualResourceInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .alproto.AssignResourceInfo assign_resource = 1;
  inline bool has_assign_resource() const;
  inline void clear_assign_resource();
  static const int kAssignResourceFieldNumber = 1;
  inline const ::alproto::AssignResourceInfo& assign_resource() const;
  inline ::alproto::AssignResourceInfo* mutable_assign_resource();
  inline ::alproto::AssignResourceInfo* release_assign_resource();
  
  // optional .alproto.ActualResourceInfo actual_resource = 2;
  inline bool has_actual_resource() const;
  inline void clear_actual_resource();
  static const int kActualResourceFieldNumber = 2;
  inline const ::alproto::ActualResourceInfo& actual_resource() const;
  inline ::alproto::ActualResourceInfo* mutable_actual_resource();
  inline ::alproto::ActualResourceInfo* release_actual_resource();
  
  // @@protoc_insertion_point(class_scope:alproto.AssignAndActualResourceInfo)
 private:
  inline void set_has_assign_resource();
  inline void clear_has_assign_resource();
  inline void set_has_actual_resource();
  inline void clear_has_actual_resource();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::alproto::AssignResourceInfo* assign_resource_;
  ::alproto::ActualResourceInfo* actual_resource_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ALProtocol_2eproto();
  friend void protobuf_AssignDesc_ALProtocol_2eproto();
  friend void protobuf_ShutdownFile_ALProtocol_2eproto();
  
  void InitAsDefaultInstance();
  static AssignAndActualResourceInfo* default_instance_;
};
// -------------------------------------------------------------------

class PlatformAndMachineResouceInfo : public ::google::protobuf::Message {
 public:
  PlatformAndMachineResouceInfo();
  virtual ~PlatformAndMachineResouceInfo();
  
  PlatformAndMachineResouceInfo(const PlatformAndMachineResouceInfo& from);
  
  inline PlatformAndMachineResouceInfo& operator=(const PlatformAndMachineResouceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlatformAndMachineResouceInfo& default_instance();
  
  void Swap(PlatformAndMachineResouceInfo* other);
  
  // implements Message ----------------------------------------------
  
  PlatformAndMachineResouceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlatformAndMachineResouceInfo& from);
  void MergeFrom(const PlatformAndMachineResouceInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .alproto.AssignAndActualResourceInfo platform_resource = 1;
  inline bool has_platform_resource() const;
  inline void clear_platform_resource();
  static const int kPlatformResourceFieldNumber = 1;
  inline const ::alproto::AssignAndActualResourceInfo& platform_resource() const;
  inline ::alproto::AssignAndActualResourceInfo* mutable_platform_resource();
  inline ::alproto::AssignAndActualResourceInfo* release_platform_resource();
  
  // repeated .alproto.AssignAndActualResourceInfo machine_resource = 2;
  inline int machine_resource_size() const;
  inline void clear_machine_resource();
  static const int kMachineResourceFieldNumber = 2;
  inline const ::alproto::AssignAndActualResourceInfo& machine_resource(int index) const;
  inline ::alproto::AssignAndActualResourceInfo* mutable_machine_resource(int index);
  inline ::alproto::AssignAndActualResourceInfo* add_machine_resource();
  inline const ::google::protobuf::RepeatedPtrField< ::alproto::AssignAndActualResourceInfo >&
      machine_resource() const;
  inline ::google::protobuf::RepeatedPtrField< ::alproto::AssignAndActualResourceInfo >*
      mutable_machine_resource();
  
  // @@protoc_insertion_point(class_scope:alproto.PlatformAndMachineResouceInfo)
 private:
  inline void set_has_platform_resource();
  inline void clear_has_platform_resource();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::alproto::AssignAndActualResourceInfo* platform_resource_;
  ::google::protobuf::RepeatedPtrField< ::alproto::AssignAndActualResourceInfo > machine_resource_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ALProtocol_2eproto();
  friend void protobuf_AssignDesc_ALProtocol_2eproto();
  friend void protobuf_ShutdownFile_ALProtocol_2eproto();
  
  void InitAsDefaultInstance();
  static PlatformAndMachineResouceInfo* default_instance_;
};
// -------------------------------------------------------------------

class ApplyAndUseResourceInfo : public ::google::protobuf::Message {
 public:
  ApplyAndUseResourceInfo();
  virtual ~ApplyAndUseResourceInfo();
  
  ApplyAndUseResourceInfo(const ApplyAndUseResourceInfo& from);
  
  inline ApplyAndUseResourceInfo& operator=(const ApplyAndUseResourceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ApplyAndUseResourceInfo& default_instance();
  
  void Swap(ApplyAndUseResourceInfo* other);
  
  // implements Message ----------------------------------------------
  
  ApplyAndUseResourceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ApplyAndUseResourceInfo& from);
  void MergeFrom(const ApplyAndUseResourceInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .alproto.ResourceInfo apply_resource = 1;
  inline bool has_apply_resource() const;
  inline void clear_apply_resource();
  static const int kApplyResourceFieldNumber = 1;
  inline const ::alproto::ResourceInfo& apply_resource() const;
  inline ::alproto::ResourceInfo* mutable_apply_resource();
  inline ::alproto::ResourceInfo* release_apply_resource();
  
  // optional .alproto.ResourceInfo use_resource = 2;
  inline bool has_use_resource() const;
  inline void clear_use_resource();
  static const int kUseResourceFieldNumber = 2;
  inline const ::alproto::ResourceInfo& use_resource() const;
  inline ::alproto::ResourceInfo* mutable_use_resource();
  inline ::alproto::ResourceInfo* release_use_resource();
  
  // @@protoc_insertion_point(class_scope:alproto.ApplyAndUseResourceInfo)
 private:
  inline void set_has_apply_resource();
  inline void clear_has_apply_resource();
  inline void set_has_use_resource();
  inline void clear_has_use_resource();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::alproto::ResourceInfo* apply_resource_;
  ::alproto::ResourceInfo* use_resource_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ALProtocol_2eproto();
  friend void protobuf_AssignDesc_ALProtocol_2eproto();
  friend void protobuf_ShutdownFile_ALProtocol_2eproto();
  
  void InitAsDefaultInstance();
  static ApplyAndUseResourceInfo* default_instance_;
};
// -------------------------------------------------------------------

class MachineInstanceResourceInfo : public ::google::protobuf::Message {
 public:
  MachineInstanceResourceInfo();
  virtual ~MachineInstanceResourceInfo();
  
  MachineInstanceResourceInfo(const MachineInstanceResourceInfo& from);
  
  inline MachineInstanceResourceInfo& operator=(const MachineInstanceResourceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MachineInstanceResourceInfo& default_instance();
  
  void Swap(MachineInstanceResourceInfo* other);
  
  // implements Message ----------------------------------------------
  
  MachineInstanceResourceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MachineInstanceResourceInfo& from);
  void MergeFrom(const MachineInstanceResourceInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string nc_ip = 1;
  inline bool has_nc_ip() const;
  inline void clear_nc_ip();
  static const int kNcIpFieldNumber = 1;
  inline const ::std::string& nc_ip() const;
  inline void set_nc_ip(const ::std::string& value);
  inline void set_nc_ip(const char* value);
  inline void set_nc_ip(const char* value, size_t size);
  inline ::std::string* mutable_nc_ip();
  inline ::std::string* release_nc_ip();
  
  // optional .alproto.ApplyAndUseResourceInfo machine_apply_use_resource = 2;
  inline bool has_machine_apply_use_resource() const;
  inline void clear_machine_apply_use_resource();
  static const int kMachineApplyUseResourceFieldNumber = 2;
  inline const ::alproto::ApplyAndUseResourceInfo& machine_apply_use_resource() const;
  inline ::alproto::ApplyAndUseResourceInfo* mutable_machine_apply_use_resource();
  inline ::alproto::ApplyAndUseResourceInfo* release_machine_apply_use_resource();
  
  // @@protoc_insertion_point(class_scope:alproto.MachineInstanceResourceInfo)
 private:
  inline void set_has_nc_ip();
  inline void clear_has_nc_ip();
  inline void set_has_machine_apply_use_resource();
  inline void clear_has_machine_apply_use_resource();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* nc_ip_;
  ::alproto::ApplyAndUseResourceInfo* machine_apply_use_resource_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ALProtocol_2eproto();
  friend void protobuf_AssignDesc_ALProtocol_2eproto();
  friend void protobuf_ShutdownFile_ALProtocol_2eproto();
  
  void InitAsDefaultInstance();
  static MachineInstanceResourceInfo* default_instance_;
};
// -------------------------------------------------------------------

class InstanceMachineResourceInfo : public ::google::protobuf::Message {
 public:
  InstanceMachineResourceInfo();
  virtual ~InstanceMachineResourceInfo();
  
  InstanceMachineResourceInfo(const InstanceMachineResourceInfo& from);
  
  inline InstanceMachineResourceInfo& operator=(const InstanceMachineResourceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const InstanceMachineResourceInfo& default_instance();
  
  void Swap(InstanceMachineResourceInfo* other);
  
  // implements Message ----------------------------------------------
  
  InstanceMachineResourceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InstanceMachineResourceInfo& from);
  void MergeFrom(const InstanceMachineResourceInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 framework_id = 1;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 1;
  inline ::google::protobuf::uint32 framework_id() const;
  inline void set_framework_id(::google::protobuf::uint32 value);
  
  // optional .alproto.ApplyAndUseResourceInfo instance_apply_use_resource = 2;
  inline bool has_instance_apply_use_resource() const;
  inline void clear_instance_apply_use_resource();
  static const int kInstanceApplyUseResourceFieldNumber = 2;
  inline const ::alproto::ApplyAndUseResourceInfo& instance_apply_use_resource() const;
  inline ::alproto::ApplyAndUseResourceInfo* mutable_instance_apply_use_resource();
  inline ::alproto::ApplyAndUseResourceInfo* release_instance_apply_use_resource();
  
  // @@protoc_insertion_point(class_scope:alproto.InstanceMachineResourceInfo)
 private:
  inline void set_has_framework_id();
  inline void clear_has_framework_id();
  inline void set_has_instance_apply_use_resource();
  inline void clear_has_instance_apply_use_resource();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::alproto::ApplyAndUseResourceInfo* instance_apply_use_resource_;
  ::google::protobuf::uint32 framework_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ALProtocol_2eproto();
  friend void protobuf_AssignDesc_ALProtocol_2eproto();
  friend void protobuf_ShutdownFile_ALProtocol_2eproto();
  
  void InitAsDefaultInstance();
  static InstanceMachineResourceInfo* default_instance_;
};
// -------------------------------------------------------------------

class FrameworkInstanceResourceInfo : public ::google::protobuf::Message {
 public:
  FrameworkInstanceResourceInfo();
  virtual ~FrameworkInstanceResourceInfo();
  
  FrameworkInstanceResourceInfo(const FrameworkInstanceResourceInfo& from);
  
  inline FrameworkInstanceResourceInfo& operator=(const FrameworkInstanceResourceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FrameworkInstanceResourceInfo& default_instance();
  
  void Swap(FrameworkInstanceResourceInfo* other);
  
  // implements Message ----------------------------------------------
  
  FrameworkInstanceResourceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FrameworkInstanceResourceInfo& from);
  void MergeFrom(const FrameworkInstanceResourceInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .alproto.ApplyAndUseResourceInfo instance_total_apply_use_resource = 1;
  inline bool has_instance_total_apply_use_resource() const;
  inline void clear_instance_total_apply_use_resource();
  static const int kInstanceTotalApplyUseResourceFieldNumber = 1;
  inline const ::alproto::ApplyAndUseResourceInfo& instance_total_apply_use_resource() const;
  inline ::alproto::ApplyAndUseResourceInfo* mutable_instance_total_apply_use_resource();
  inline ::alproto::ApplyAndUseResourceInfo* release_instance_total_apply_use_resource();
  
  // repeated .alproto.MachineInstanceResourceInfo instance_at_machine_resource = 2;
  inline int instance_at_machine_resource_size() const;
  inline void clear_instance_at_machine_resource();
  static const int kInstanceAtMachineResourceFieldNumber = 2;
  inline const ::alproto::MachineInstanceResourceInfo& instance_at_machine_resource(int index) const;
  inline ::alproto::MachineInstanceResourceInfo* mutable_instance_at_machine_resource(int index);
  inline ::alproto::MachineInstanceResourceInfo* add_instance_at_machine_resource();
  inline const ::google::protobuf::RepeatedPtrField< ::alproto::MachineInstanceResourceInfo >&
      instance_at_machine_resource() const;
  inline ::google::protobuf::RepeatedPtrField< ::alproto::MachineInstanceResourceInfo >*
      mutable_instance_at_machine_resource();
  
  // repeated .alproto.InstanceMachineResourceInfo machine_has_instance_resource = 3;
  inline int machine_has_instance_resource_size() const;
  inline void clear_machine_has_instance_resource();
  static const int kMachineHasInstanceResourceFieldNumber = 3;
  inline const ::alproto::InstanceMachineResourceInfo& machine_has_instance_resource(int index) const;
  inline ::alproto::InstanceMachineResourceInfo* mutable_machine_has_instance_resource(int index);
  inline ::alproto::InstanceMachineResourceInfo* add_machine_has_instance_resource();
  inline const ::google::protobuf::RepeatedPtrField< ::alproto::InstanceMachineResourceInfo >&
      machine_has_instance_resource() const;
  inline ::google::protobuf::RepeatedPtrField< ::alproto::InstanceMachineResourceInfo >*
      mutable_machine_has_instance_resource();
  
  // @@protoc_insertion_point(class_scope:alproto.FrameworkInstanceResourceInfo)
 private:
  inline void set_has_instance_total_apply_use_resource();
  inline void clear_has_instance_total_apply_use_resource();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::alproto::ApplyAndUseResourceInfo* instance_total_apply_use_resource_;
  ::google::protobuf::RepeatedPtrField< ::alproto::MachineInstanceResourceInfo > instance_at_machine_resource_;
  ::google::protobuf::RepeatedPtrField< ::alproto::InstanceMachineResourceInfo > machine_has_instance_resource_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_ALProtocol_2eproto();
  friend void protobuf_AssignDesc_ALProtocol_2eproto();
  friend void protobuf_ShutdownFile_ALProtocol_2eproto();
  
  void InitAsDefaultInstance();
  static FrameworkInstanceResourceInfo* default_instance_;
};
// -------------------------------------------------------------------

class NetworkAddress : public ::google::protobuf::Message {
 public:
  NetworkAddress();
  virtual ~NetworkAddress();
  
  NetworkAddress(const NetworkAddress& from);
  
  inline NetworkAddress& operator=(const NetworkAddress& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NetworkAddress& default_instance();
  
  void Swap(NetworkAddress* other);
  
  // implements Message ----------------------------------------------
  
  NetworkAddress* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NetworkAddress& from);
  void MergeFrom(const NetworkAddress& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string node_ip = 1;
  inline bool has_node_ip() const;
  inline void clear_node_ip();
  static const int kNodeIpFieldNumber = 1;
  inline const ::std::string& node_ip() const;
  inline void set_node_ip(const ::std::string& value);
  inline void set_node_ip(const char* value);
  inline void set_node_ip(const char* value, size_t size);
  inline ::std::string* mutable_node_ip();
  inline ::std::string* release_node_ip();
  
  // optional uint32 node_port = 2;
  inline bool has_node_port() const;
  inline void clear_node_port();
  static const int kNodePortFieldNumber = 2;
  inline ::google::protobuf::uint32 node_port() const;
  inline void set_node_port(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:alproto.NetworkAddress)
 private:
  inline void set_has_node_ip();
  inline void clear_has_node_ip();
  inline void set_has_node_port();
  inline void clear_has_node_port();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* node_ip_;
  ::google::protobuf::uint32 node_port_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ALProtocol_2eproto();
  friend void protobuf_AssignDesc_ALProtocol_2eproto();
  friend void protobuf_ShutdownFile_ALProtocol_2eproto();
  
  void InitAsDefaultInstance();
  static NetworkAddress* default_instance_;
};
// ===================================================================


// ===================================================================

// GpuResourceInfo

// required string gpu_name = 1;
inline bool GpuResourceInfo::has_gpu_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GpuResourceInfo::set_has_gpu_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GpuResourceInfo::clear_has_gpu_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GpuResourceInfo::clear_gpu_name() {
  if (gpu_name_ != &::google::protobuf::internal::kEmptyString) {
    gpu_name_->clear();
  }
  clear_has_gpu_name();
}
inline const ::std::string& GpuResourceInfo::gpu_name() const {
  return *gpu_name_;
}
inline void GpuResourceInfo::set_gpu_name(const ::std::string& value) {
  set_has_gpu_name();
  if (gpu_name_ == &::google::protobuf::internal::kEmptyString) {
    gpu_name_ = new ::std::string;
  }
  gpu_name_->assign(value);
}
inline void GpuResourceInfo::set_gpu_name(const char* value) {
  set_has_gpu_name();
  if (gpu_name_ == &::google::protobuf::internal::kEmptyString) {
    gpu_name_ = new ::std::string;
  }
  gpu_name_->assign(value);
}
inline void GpuResourceInfo::set_gpu_name(const char* value, size_t size) {
  set_has_gpu_name();
  if (gpu_name_ == &::google::protobuf::internal::kEmptyString) {
    gpu_name_ = new ::std::string;
  }
  gpu_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GpuResourceInfo::mutable_gpu_name() {
  set_has_gpu_name();
  if (gpu_name_ == &::google::protobuf::internal::kEmptyString) {
    gpu_name_ = new ::std::string;
  }
  return gpu_name_;
}
inline ::std::string* GpuResourceInfo::release_gpu_name() {
  clear_has_gpu_name();
  if (gpu_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gpu_name_;
    gpu_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 gpu_mem_size = 2;
inline bool GpuResourceInfo::has_gpu_mem_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GpuResourceInfo::set_has_gpu_mem_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GpuResourceInfo::clear_has_gpu_mem_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GpuResourceInfo::clear_gpu_mem_size() {
  gpu_mem_size_ = 0u;
  clear_has_gpu_mem_size();
}
inline ::google::protobuf::uint32 GpuResourceInfo::gpu_mem_size() const {
  return gpu_mem_size_;
}
inline void GpuResourceInfo::set_gpu_mem_size(::google::protobuf::uint32 value) {
  set_has_gpu_mem_size();
  gpu_mem_size_ = value;
}

// -------------------------------------------------------------------

// ResourceInfo

// required double cpu_num = 1;
inline bool ResourceInfo::has_cpu_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResourceInfo::set_has_cpu_num() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResourceInfo::clear_has_cpu_num() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResourceInfo::clear_cpu_num() {
  cpu_num_ = 0;
  clear_has_cpu_num();
}
inline double ResourceInfo::cpu_num() const {
  return cpu_num_;
}
inline void ResourceInfo::set_cpu_num(double value) {
  set_has_cpu_num();
  cpu_num_ = value;
}

// required uint32 cpu_mem_size = 2;
inline bool ResourceInfo::has_cpu_mem_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResourceInfo::set_has_cpu_mem_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResourceInfo::clear_has_cpu_mem_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResourceInfo::clear_cpu_mem_size() {
  cpu_mem_size_ = 0u;
  clear_has_cpu_mem_size();
}
inline ::google::protobuf::uint32 ResourceInfo::cpu_mem_size() const {
  return cpu_mem_size_;
}
inline void ResourceInfo::set_cpu_mem_size(::google::protobuf::uint32 value) {
  set_has_cpu_mem_size();
  cpu_mem_size_ = value;
}

// optional uint32 gpu_num = 3;
inline bool ResourceInfo::has_gpu_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResourceInfo::set_has_gpu_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResourceInfo::clear_has_gpu_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResourceInfo::clear_gpu_num() {
  gpu_num_ = 0u;
  clear_has_gpu_num();
}
inline ::google::protobuf::uint32 ResourceInfo::gpu_num() const {
  return gpu_num_;
}
inline void ResourceInfo::set_gpu_num(::google::protobuf::uint32 value) {
  set_has_gpu_num();
  gpu_num_ = value;
}

// repeated .alproto.GpuResourceInfo gpu_resource_info = 4;
inline int ResourceInfo::gpu_resource_info_size() const {
  return gpu_resource_info_.size();
}
inline void ResourceInfo::clear_gpu_resource_info() {
  gpu_resource_info_.Clear();
}
inline const ::alproto::GpuResourceInfo& ResourceInfo::gpu_resource_info(int index) const {
  return gpu_resource_info_.Get(index);
}
inline ::alproto::GpuResourceInfo* ResourceInfo::mutable_gpu_resource_info(int index) {
  return gpu_resource_info_.Mutable(index);
}
inline ::alproto::GpuResourceInfo* ResourceInfo::add_gpu_resource_info() {
  return gpu_resource_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::alproto::GpuResourceInfo >&
ResourceInfo::gpu_resource_info() const {
  return gpu_resource_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::alproto::GpuResourceInfo >*
ResourceInfo::mutable_gpu_resource_info() {
  return &gpu_resource_info_;
}

// -------------------------------------------------------------------

// FrameworkIDInfo

// required uint32 framework_id = 1;
inline bool FrameworkIDInfo::has_framework_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FrameworkIDInfo::set_has_framework_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FrameworkIDInfo::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FrameworkIDInfo::clear_framework_id() {
  framework_id_ = 0u;
  clear_has_framework_id();
}
inline ::google::protobuf::uint32 FrameworkIDInfo::framework_id() const {
  return framework_id_;
}
inline void FrameworkIDInfo::set_framework_id(::google::protobuf::uint32 value) {
  set_has_framework_id();
  framework_id_ = value;
}

// -------------------------------------------------------------------

// FrameworkInstanceInfo

// required uint32 framework_id = 1;
inline bool FrameworkInstanceInfo::has_framework_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FrameworkInstanceInfo::set_has_framework_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FrameworkInstanceInfo::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FrameworkInstanceInfo::clear_framework_id() {
  framework_id_ = 0u;
  clear_has_framework_id();
}
inline ::google::protobuf::uint32 FrameworkInstanceInfo::framework_id() const {
  return framework_id_;
}
inline void FrameworkInstanceInfo::set_framework_id(::google::protobuf::uint32 value) {
  set_has_framework_id();
  framework_id_ = value;
}

// required uint32 framework_instance_id = 2;
inline bool FrameworkInstanceInfo::has_framework_instance_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FrameworkInstanceInfo::set_has_framework_instance_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FrameworkInstanceInfo::clear_has_framework_instance_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FrameworkInstanceInfo::clear_framework_instance_id() {
  framework_instance_id_ = 0u;
  clear_has_framework_instance_id();
}
inline ::google::protobuf::uint32 FrameworkInstanceInfo::framework_instance_id() const {
  return framework_instance_id_;
}
inline void FrameworkInstanceInfo::set_framework_instance_id(::google::protobuf::uint32 value) {
  set_has_framework_instance_id();
  framework_instance_id_ = value;
}

// -------------------------------------------------------------------

// StartRootModule

// required uint32 framework_id = 1;
inline bool StartRootModule::has_framework_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StartRootModule::set_has_framework_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StartRootModule::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StartRootModule::clear_framework_id() {
  framework_id_ = 0u;
  clear_has_framework_id();
}
inline ::google::protobuf::uint32 StartRootModule::framework_id() const {
  return framework_id_;
}
inline void StartRootModule::set_framework_id(::google::protobuf::uint32 value) {
  set_has_framework_id();
  framework_id_ = value;
}

// optional string image_lable = 2;
inline bool StartRootModule::has_image_lable() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StartRootModule::set_has_image_lable() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StartRootModule::clear_has_image_lable() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StartRootModule::clear_image_lable() {
  if (image_lable_ != &::google::protobuf::internal::kEmptyString) {
    image_lable_->clear();
  }
  clear_has_image_lable();
}
inline const ::std::string& StartRootModule::image_lable() const {
  return *image_lable_;
}
inline void StartRootModule::set_image_lable(const ::std::string& value) {
  set_has_image_lable();
  if (image_lable_ == &::google::protobuf::internal::kEmptyString) {
    image_lable_ = new ::std::string;
  }
  image_lable_->assign(value);
}
inline void StartRootModule::set_image_lable(const char* value) {
  set_has_image_lable();
  if (image_lable_ == &::google::protobuf::internal::kEmptyString) {
    image_lable_ = new ::std::string;
  }
  image_lable_->assign(value);
}
inline void StartRootModule::set_image_lable(const char* value, size_t size) {
  set_has_image_lable();
  if (image_lable_ == &::google::protobuf::internal::kEmptyString) {
    image_lable_ = new ::std::string;
  }
  image_lable_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StartRootModule::mutable_image_lable() {
  set_has_image_lable();
  if (image_lable_ == &::google::protobuf::internal::kEmptyString) {
    image_lable_ = new ::std::string;
  }
  return image_lable_;
}
inline ::std::string* StartRootModule::release_image_lable() {
  clear_has_image_lable();
  if (image_lable_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = image_lable_;
    image_lable_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string module_name = 3;
inline bool StartRootModule::has_module_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StartRootModule::set_has_module_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StartRootModule::clear_has_module_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StartRootModule::clear_module_name() {
  if (module_name_ != &::google::protobuf::internal::kEmptyString) {
    module_name_->clear();
  }
  clear_has_module_name();
}
inline const ::std::string& StartRootModule::module_name() const {
  return *module_name_;
}
inline void StartRootModule::set_module_name(const ::std::string& value) {
  set_has_module_name();
  if (module_name_ == &::google::protobuf::internal::kEmptyString) {
    module_name_ = new ::std::string;
  }
  module_name_->assign(value);
}
inline void StartRootModule::set_module_name(const char* value) {
  set_has_module_name();
  if (module_name_ == &::google::protobuf::internal::kEmptyString) {
    module_name_ = new ::std::string;
  }
  module_name_->assign(value);
}
inline void StartRootModule::set_module_name(const char* value, size_t size) {
  set_has_module_name();
  if (module_name_ == &::google::protobuf::internal::kEmptyString) {
    module_name_ = new ::std::string;
  }
  module_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StartRootModule::mutable_module_name() {
  set_has_module_name();
  if (module_name_ == &::google::protobuf::internal::kEmptyString) {
    module_name_ = new ::std::string;
  }
  return module_name_;
}
inline ::std::string* StartRootModule::release_module_name() {
  clear_has_module_name();
  if (module_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = module_name_;
    module_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string location_file_path = 4;
inline bool StartRootModule::has_location_file_path() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StartRootModule::set_has_location_file_path() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StartRootModule::clear_has_location_file_path() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StartRootModule::clear_location_file_path() {
  if (location_file_path_ != &::google::protobuf::internal::kEmptyString) {
    location_file_path_->clear();
  }
  clear_has_location_file_path();
}
inline const ::std::string& StartRootModule::location_file_path() const {
  return *location_file_path_;
}
inline void StartRootModule::set_location_file_path(const ::std::string& value) {
  set_has_location_file_path();
  if (location_file_path_ == &::google::protobuf::internal::kEmptyString) {
    location_file_path_ = new ::std::string;
  }
  location_file_path_->assign(value);
}
inline void StartRootModule::set_location_file_path(const char* value) {
  set_has_location_file_path();
  if (location_file_path_ == &::google::protobuf::internal::kEmptyString) {
    location_file_path_ = new ::std::string;
  }
  location_file_path_->assign(value);
}
inline void StartRootModule::set_location_file_path(const char* value, size_t size) {
  set_has_location_file_path();
  if (location_file_path_ == &::google::protobuf::internal::kEmptyString) {
    location_file_path_ = new ::std::string;
  }
  location_file_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StartRootModule::mutable_location_file_path() {
  set_has_location_file_path();
  if (location_file_path_ == &::google::protobuf::internal::kEmptyString) {
    location_file_path_ = new ::std::string;
  }
  return location_file_path_;
}
inline ::std::string* StartRootModule::release_location_file_path() {
  clear_has_location_file_path();
  if (location_file_path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = location_file_path_;
    location_file_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated string nc_ip = 5;
inline int StartRootModule::nc_ip_size() const {
  return nc_ip_.size();
}
inline void StartRootModule::clear_nc_ip() {
  nc_ip_.Clear();
}
inline const ::std::string& StartRootModule::nc_ip(int index) const {
  return nc_ip_.Get(index);
}
inline ::std::string* StartRootModule::mutable_nc_ip(int index) {
  return nc_ip_.Mutable(index);
}
inline void StartRootModule::set_nc_ip(int index, const ::std::string& value) {
  nc_ip_.Mutable(index)->assign(value);
}
inline void StartRootModule::set_nc_ip(int index, const char* value) {
  nc_ip_.Mutable(index)->assign(value);
}
inline void StartRootModule::set_nc_ip(int index, const char* value, size_t size) {
  nc_ip_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StartRootModule::add_nc_ip() {
  return nc_ip_.Add();
}
inline void StartRootModule::add_nc_ip(const ::std::string& value) {
  nc_ip_.Add()->assign(value);
}
inline void StartRootModule::add_nc_ip(const char* value) {
  nc_ip_.Add()->assign(value);
}
inline void StartRootModule::add_nc_ip(const char* value, size_t size) {
  nc_ip_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
StartRootModule::nc_ip() const {
  return nc_ip_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
StartRootModule::mutable_nc_ip() {
  return &nc_ip_;
}

// optional .alproto.ResourceInfo request_resource_size = 6;
inline bool StartRootModule::has_request_resource_size() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void StartRootModule::set_has_request_resource_size() {
  _has_bits_[0] |= 0x00000020u;
}
inline void StartRootModule::clear_has_request_resource_size() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void StartRootModule::clear_request_resource_size() {
  if (request_resource_size_ != NULL) request_resource_size_->::alproto::ResourceInfo::Clear();
  clear_has_request_resource_size();
}
inline const ::alproto::ResourceInfo& StartRootModule::request_resource_size() const {
  return request_resource_size_ != NULL ? *request_resource_size_ : *default_instance_->request_resource_size_;
}
inline ::alproto::ResourceInfo* StartRootModule::mutable_request_resource_size() {
  set_has_request_resource_size();
  if (request_resource_size_ == NULL) request_resource_size_ = new ::alproto::ResourceInfo;
  return request_resource_size_;
}
inline ::alproto::ResourceInfo* StartRootModule::release_request_resource_size() {
  clear_has_request_resource_size();
  ::alproto::ResourceInfo* temp = request_resource_size_;
  request_resource_size_ = NULL;
  return temp;
}

// optional uint32 listen_num = 7;
inline bool StartRootModule::has_listen_num() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void StartRootModule::set_has_listen_num() {
  _has_bits_[0] |= 0x00000040u;
}
inline void StartRootModule::clear_has_listen_num() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void StartRootModule::clear_listen_num() {
  listen_num_ = 0u;
  clear_has_listen_num();
}
inline ::google::protobuf::uint32 StartRootModule::listen_num() const {
  return listen_num_;
}
inline void StartRootModule::set_listen_num(::google::protobuf::uint32 value) {
  set_has_listen_num();
  listen_num_ = value;
}

// -------------------------------------------------------------------

// AssignResourceInfo

// required .alproto.ResourceInfo total_have_resource = 1;
inline bool AssignResourceInfo::has_total_have_resource() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AssignResourceInfo::set_has_total_have_resource() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AssignResourceInfo::clear_has_total_have_resource() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AssignResourceInfo::clear_total_have_resource() {
  if (total_have_resource_ != NULL) total_have_resource_->::alproto::ResourceInfo::Clear();
  clear_has_total_have_resource();
}
inline const ::alproto::ResourceInfo& AssignResourceInfo::total_have_resource() const {
  return total_have_resource_ != NULL ? *total_have_resource_ : *default_instance_->total_have_resource_;
}
inline ::alproto::ResourceInfo* AssignResourceInfo::mutable_total_have_resource() {
  set_has_total_have_resource();
  if (total_have_resource_ == NULL) total_have_resource_ = new ::alproto::ResourceInfo;
  return total_have_resource_;
}
inline ::alproto::ResourceInfo* AssignResourceInfo::release_total_have_resource() {
  clear_has_total_have_resource();
  ::alproto::ResourceInfo* temp = total_have_resource_;
  total_have_resource_ = NULL;
  return temp;
}

// optional .alproto.ResourceInfo total_not_assign_resource = 2;
inline bool AssignResourceInfo::has_total_not_assign_resource() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AssignResourceInfo::set_has_total_not_assign_resource() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AssignResourceInfo::clear_has_total_not_assign_resource() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AssignResourceInfo::clear_total_not_assign_resource() {
  if (total_not_assign_resource_ != NULL) total_not_assign_resource_->::alproto::ResourceInfo::Clear();
  clear_has_total_not_assign_resource();
}
inline const ::alproto::ResourceInfo& AssignResourceInfo::total_not_assign_resource() const {
  return total_not_assign_resource_ != NULL ? *total_not_assign_resource_ : *default_instance_->total_not_assign_resource_;
}
inline ::alproto::ResourceInfo* AssignResourceInfo::mutable_total_not_assign_resource() {
  set_has_total_not_assign_resource();
  if (total_not_assign_resource_ == NULL) total_not_assign_resource_ = new ::alproto::ResourceInfo;
  return total_not_assign_resource_;
}
inline ::alproto::ResourceInfo* AssignResourceInfo::release_total_not_assign_resource() {
  clear_has_total_not_assign_resource();
  ::alproto::ResourceInfo* temp = total_not_assign_resource_;
  total_not_assign_resource_ = NULL;
  return temp;
}

// optional .alproto.ResourceInfo total_already_assign_resource = 3;
inline bool AssignResourceInfo::has_total_already_assign_resource() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AssignResourceInfo::set_has_total_already_assign_resource() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AssignResourceInfo::clear_has_total_already_assign_resource() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AssignResourceInfo::clear_total_already_assign_resource() {
  if (total_already_assign_resource_ != NULL) total_already_assign_resource_->::alproto::ResourceInfo::Clear();
  clear_has_total_already_assign_resource();
}
inline const ::alproto::ResourceInfo& AssignResourceInfo::total_already_assign_resource() const {
  return total_already_assign_resource_ != NULL ? *total_already_assign_resource_ : *default_instance_->total_already_assign_resource_;
}
inline ::alproto::ResourceInfo* AssignResourceInfo::mutable_total_already_assign_resource() {
  set_has_total_already_assign_resource();
  if (total_already_assign_resource_ == NULL) total_already_assign_resource_ = new ::alproto::ResourceInfo;
  return total_already_assign_resource_;
}
inline ::alproto::ResourceInfo* AssignResourceInfo::release_total_already_assign_resource() {
  clear_has_total_already_assign_resource();
  ::alproto::ResourceInfo* temp = total_already_assign_resource_;
  total_already_assign_resource_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// ActualResourceInfo

// required .alproto.ResourceInfo total_use_resource = 1;
inline bool ActualResourceInfo::has_total_use_resource() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActualResourceInfo::set_has_total_use_resource() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActualResourceInfo::clear_has_total_use_resource() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActualResourceInfo::clear_total_use_resource() {
  if (total_use_resource_ != NULL) total_use_resource_->::alproto::ResourceInfo::Clear();
  clear_has_total_use_resource();
}
inline const ::alproto::ResourceInfo& ActualResourceInfo::total_use_resource() const {
  return total_use_resource_ != NULL ? *total_use_resource_ : *default_instance_->total_use_resource_;
}
inline ::alproto::ResourceInfo* ActualResourceInfo::mutable_total_use_resource() {
  set_has_total_use_resource();
  if (total_use_resource_ == NULL) total_use_resource_ = new ::alproto::ResourceInfo;
  return total_use_resource_;
}
inline ::alproto::ResourceInfo* ActualResourceInfo::release_total_use_resource() {
  clear_has_total_use_resource();
  ::alproto::ResourceInfo* temp = total_use_resource_;
  total_use_resource_ = NULL;
  return temp;
}

// optional .alproto.ResourceInfo total_not_use_resource = 2;
inline bool ActualResourceInfo::has_total_not_use_resource() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActualResourceInfo::set_has_total_not_use_resource() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActualResourceInfo::clear_has_total_not_use_resource() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActualResourceInfo::clear_total_not_use_resource() {
  if (total_not_use_resource_ != NULL) total_not_use_resource_->::alproto::ResourceInfo::Clear();
  clear_has_total_not_use_resource();
}
inline const ::alproto::ResourceInfo& ActualResourceInfo::total_not_use_resource() const {
  return total_not_use_resource_ != NULL ? *total_not_use_resource_ : *default_instance_->total_not_use_resource_;
}
inline ::alproto::ResourceInfo* ActualResourceInfo::mutable_total_not_use_resource() {
  set_has_total_not_use_resource();
  if (total_not_use_resource_ == NULL) total_not_use_resource_ = new ::alproto::ResourceInfo;
  return total_not_use_resource_;
}
inline ::alproto::ResourceInfo* ActualResourceInfo::release_total_not_use_resource() {
  clear_has_total_not_use_resource();
  ::alproto::ResourceInfo* temp = total_not_use_resource_;
  total_not_use_resource_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// AssignAndActualResourceInfo

// required .alproto.AssignResourceInfo assign_resource = 1;
inline bool AssignAndActualResourceInfo::has_assign_resource() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AssignAndActualResourceInfo::set_has_assign_resource() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AssignAndActualResourceInfo::clear_has_assign_resource() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AssignAndActualResourceInfo::clear_assign_resource() {
  if (assign_resource_ != NULL) assign_resource_->::alproto::AssignResourceInfo::Clear();
  clear_has_assign_resource();
}
inline const ::alproto::AssignResourceInfo& AssignAndActualResourceInfo::assign_resource() const {
  return assign_resource_ != NULL ? *assign_resource_ : *default_instance_->assign_resource_;
}
inline ::alproto::AssignResourceInfo* AssignAndActualResourceInfo::mutable_assign_resource() {
  set_has_assign_resource();
  if (assign_resource_ == NULL) assign_resource_ = new ::alproto::AssignResourceInfo;
  return assign_resource_;
}
inline ::alproto::AssignResourceInfo* AssignAndActualResourceInfo::release_assign_resource() {
  clear_has_assign_resource();
  ::alproto::AssignResourceInfo* temp = assign_resource_;
  assign_resource_ = NULL;
  return temp;
}

// optional .alproto.ActualResourceInfo actual_resource = 2;
inline bool AssignAndActualResourceInfo::has_actual_resource() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AssignAndActualResourceInfo::set_has_actual_resource() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AssignAndActualResourceInfo::clear_has_actual_resource() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AssignAndActualResourceInfo::clear_actual_resource() {
  if (actual_resource_ != NULL) actual_resource_->::alproto::ActualResourceInfo::Clear();
  clear_has_actual_resource();
}
inline const ::alproto::ActualResourceInfo& AssignAndActualResourceInfo::actual_resource() const {
  return actual_resource_ != NULL ? *actual_resource_ : *default_instance_->actual_resource_;
}
inline ::alproto::ActualResourceInfo* AssignAndActualResourceInfo::mutable_actual_resource() {
  set_has_actual_resource();
  if (actual_resource_ == NULL) actual_resource_ = new ::alproto::ActualResourceInfo;
  return actual_resource_;
}
inline ::alproto::ActualResourceInfo* AssignAndActualResourceInfo::release_actual_resource() {
  clear_has_actual_resource();
  ::alproto::ActualResourceInfo* temp = actual_resource_;
  actual_resource_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// PlatformAndMachineResouceInfo

// required .alproto.AssignAndActualResourceInfo platform_resource = 1;
inline bool PlatformAndMachineResouceInfo::has_platform_resource() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlatformAndMachineResouceInfo::set_has_platform_resource() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlatformAndMachineResouceInfo::clear_has_platform_resource() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlatformAndMachineResouceInfo::clear_platform_resource() {
  if (platform_resource_ != NULL) platform_resource_->::alproto::AssignAndActualResourceInfo::Clear();
  clear_has_platform_resource();
}
inline const ::alproto::AssignAndActualResourceInfo& PlatformAndMachineResouceInfo::platform_resource() const {
  return platform_resource_ != NULL ? *platform_resource_ : *default_instance_->platform_resource_;
}
inline ::alproto::AssignAndActualResourceInfo* PlatformAndMachineResouceInfo::mutable_platform_resource() {
  set_has_platform_resource();
  if (platform_resource_ == NULL) platform_resource_ = new ::alproto::AssignAndActualResourceInfo;
  return platform_resource_;
}
inline ::alproto::AssignAndActualResourceInfo* PlatformAndMachineResouceInfo::release_platform_resource() {
  clear_has_platform_resource();
  ::alproto::AssignAndActualResourceInfo* temp = platform_resource_;
  platform_resource_ = NULL;
  return temp;
}

// repeated .alproto.AssignAndActualResourceInfo machine_resource = 2;
inline int PlatformAndMachineResouceInfo::machine_resource_size() const {
  return machine_resource_.size();
}
inline void PlatformAndMachineResouceInfo::clear_machine_resource() {
  machine_resource_.Clear();
}
inline const ::alproto::AssignAndActualResourceInfo& PlatformAndMachineResouceInfo::machine_resource(int index) const {
  return machine_resource_.Get(index);
}
inline ::alproto::AssignAndActualResourceInfo* PlatformAndMachineResouceInfo::mutable_machine_resource(int index) {
  return machine_resource_.Mutable(index);
}
inline ::alproto::AssignAndActualResourceInfo* PlatformAndMachineResouceInfo::add_machine_resource() {
  return machine_resource_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::alproto::AssignAndActualResourceInfo >&
PlatformAndMachineResouceInfo::machine_resource() const {
  return machine_resource_;
}
inline ::google::protobuf::RepeatedPtrField< ::alproto::AssignAndActualResourceInfo >*
PlatformAndMachineResouceInfo::mutable_machine_resource() {
  return &machine_resource_;
}

// -------------------------------------------------------------------

// ApplyAndUseResourceInfo

// required .alproto.ResourceInfo apply_resource = 1;
inline bool ApplyAndUseResourceInfo::has_apply_resource() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ApplyAndUseResourceInfo::set_has_apply_resource() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ApplyAndUseResourceInfo::clear_has_apply_resource() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ApplyAndUseResourceInfo::clear_apply_resource() {
  if (apply_resource_ != NULL) apply_resource_->::alproto::ResourceInfo::Clear();
  clear_has_apply_resource();
}
inline const ::alproto::ResourceInfo& ApplyAndUseResourceInfo::apply_resource() const {
  return apply_resource_ != NULL ? *apply_resource_ : *default_instance_->apply_resource_;
}
inline ::alproto::ResourceInfo* ApplyAndUseResourceInfo::mutable_apply_resource() {
  set_has_apply_resource();
  if (apply_resource_ == NULL) apply_resource_ = new ::alproto::ResourceInfo;
  return apply_resource_;
}
inline ::alproto::ResourceInfo* ApplyAndUseResourceInfo::release_apply_resource() {
  clear_has_apply_resource();
  ::alproto::ResourceInfo* temp = apply_resource_;
  apply_resource_ = NULL;
  return temp;
}

// optional .alproto.ResourceInfo use_resource = 2;
inline bool ApplyAndUseResourceInfo::has_use_resource() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ApplyAndUseResourceInfo::set_has_use_resource() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ApplyAndUseResourceInfo::clear_has_use_resource() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ApplyAndUseResourceInfo::clear_use_resource() {
  if (use_resource_ != NULL) use_resource_->::alproto::ResourceInfo::Clear();
  clear_has_use_resource();
}
inline const ::alproto::ResourceInfo& ApplyAndUseResourceInfo::use_resource() const {
  return use_resource_ != NULL ? *use_resource_ : *default_instance_->use_resource_;
}
inline ::alproto::ResourceInfo* ApplyAndUseResourceInfo::mutable_use_resource() {
  set_has_use_resource();
  if (use_resource_ == NULL) use_resource_ = new ::alproto::ResourceInfo;
  return use_resource_;
}
inline ::alproto::ResourceInfo* ApplyAndUseResourceInfo::release_use_resource() {
  clear_has_use_resource();
  ::alproto::ResourceInfo* temp = use_resource_;
  use_resource_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// MachineInstanceResourceInfo

// required string nc_ip = 1;
inline bool MachineInstanceResourceInfo::has_nc_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MachineInstanceResourceInfo::set_has_nc_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MachineInstanceResourceInfo::clear_has_nc_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MachineInstanceResourceInfo::clear_nc_ip() {
  if (nc_ip_ != &::google::protobuf::internal::kEmptyString) {
    nc_ip_->clear();
  }
  clear_has_nc_ip();
}
inline const ::std::string& MachineInstanceResourceInfo::nc_ip() const {
  return *nc_ip_;
}
inline void MachineInstanceResourceInfo::set_nc_ip(const ::std::string& value) {
  set_has_nc_ip();
  if (nc_ip_ == &::google::protobuf::internal::kEmptyString) {
    nc_ip_ = new ::std::string;
  }
  nc_ip_->assign(value);
}
inline void MachineInstanceResourceInfo::set_nc_ip(const char* value) {
  set_has_nc_ip();
  if (nc_ip_ == &::google::protobuf::internal::kEmptyString) {
    nc_ip_ = new ::std::string;
  }
  nc_ip_->assign(value);
}
inline void MachineInstanceResourceInfo::set_nc_ip(const char* value, size_t size) {
  set_has_nc_ip();
  if (nc_ip_ == &::google::protobuf::internal::kEmptyString) {
    nc_ip_ = new ::std::string;
  }
  nc_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MachineInstanceResourceInfo::mutable_nc_ip() {
  set_has_nc_ip();
  if (nc_ip_ == &::google::protobuf::internal::kEmptyString) {
    nc_ip_ = new ::std::string;
  }
  return nc_ip_;
}
inline ::std::string* MachineInstanceResourceInfo::release_nc_ip() {
  clear_has_nc_ip();
  if (nc_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nc_ip_;
    nc_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .alproto.ApplyAndUseResourceInfo machine_apply_use_resource = 2;
inline bool MachineInstanceResourceInfo::has_machine_apply_use_resource() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MachineInstanceResourceInfo::set_has_machine_apply_use_resource() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MachineInstanceResourceInfo::clear_has_machine_apply_use_resource() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MachineInstanceResourceInfo::clear_machine_apply_use_resource() {
  if (machine_apply_use_resource_ != NULL) machine_apply_use_resource_->::alproto::ApplyAndUseResourceInfo::Clear();
  clear_has_machine_apply_use_resource();
}
inline const ::alproto::ApplyAndUseResourceInfo& MachineInstanceResourceInfo::machine_apply_use_resource() const {
  return machine_apply_use_resource_ != NULL ? *machine_apply_use_resource_ : *default_instance_->machine_apply_use_resource_;
}
inline ::alproto::ApplyAndUseResourceInfo* MachineInstanceResourceInfo::mutable_machine_apply_use_resource() {
  set_has_machine_apply_use_resource();
  if (machine_apply_use_resource_ == NULL) machine_apply_use_resource_ = new ::alproto::ApplyAndUseResourceInfo;
  return machine_apply_use_resource_;
}
inline ::alproto::ApplyAndUseResourceInfo* MachineInstanceResourceInfo::release_machine_apply_use_resource() {
  clear_has_machine_apply_use_resource();
  ::alproto::ApplyAndUseResourceInfo* temp = machine_apply_use_resource_;
  machine_apply_use_resource_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// InstanceMachineResourceInfo

// required uint32 framework_id = 1;
inline bool InstanceMachineResourceInfo::has_framework_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InstanceMachineResourceInfo::set_has_framework_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InstanceMachineResourceInfo::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InstanceMachineResourceInfo::clear_framework_id() {
  framework_id_ = 0u;
  clear_has_framework_id();
}
inline ::google::protobuf::uint32 InstanceMachineResourceInfo::framework_id() const {
  return framework_id_;
}
inline void InstanceMachineResourceInfo::set_framework_id(::google::protobuf::uint32 value) {
  set_has_framework_id();
  framework_id_ = value;
}

// optional .alproto.ApplyAndUseResourceInfo instance_apply_use_resource = 2;
inline bool InstanceMachineResourceInfo::has_instance_apply_use_resource() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InstanceMachineResourceInfo::set_has_instance_apply_use_resource() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InstanceMachineResourceInfo::clear_has_instance_apply_use_resource() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InstanceMachineResourceInfo::clear_instance_apply_use_resource() {
  if (instance_apply_use_resource_ != NULL) instance_apply_use_resource_->::alproto::ApplyAndUseResourceInfo::Clear();
  clear_has_instance_apply_use_resource();
}
inline const ::alproto::ApplyAndUseResourceInfo& InstanceMachineResourceInfo::instance_apply_use_resource() const {
  return instance_apply_use_resource_ != NULL ? *instance_apply_use_resource_ : *default_instance_->instance_apply_use_resource_;
}
inline ::alproto::ApplyAndUseResourceInfo* InstanceMachineResourceInfo::mutable_instance_apply_use_resource() {
  set_has_instance_apply_use_resource();
  if (instance_apply_use_resource_ == NULL) instance_apply_use_resource_ = new ::alproto::ApplyAndUseResourceInfo;
  return instance_apply_use_resource_;
}
inline ::alproto::ApplyAndUseResourceInfo* InstanceMachineResourceInfo::release_instance_apply_use_resource() {
  clear_has_instance_apply_use_resource();
  ::alproto::ApplyAndUseResourceInfo* temp = instance_apply_use_resource_;
  instance_apply_use_resource_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// FrameworkInstanceResourceInfo

// required .alproto.ApplyAndUseResourceInfo instance_total_apply_use_resource = 1;
inline bool FrameworkInstanceResourceInfo::has_instance_total_apply_use_resource() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FrameworkInstanceResourceInfo::set_has_instance_total_apply_use_resource() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FrameworkInstanceResourceInfo::clear_has_instance_total_apply_use_resource() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FrameworkInstanceResourceInfo::clear_instance_total_apply_use_resource() {
  if (instance_total_apply_use_resource_ != NULL) instance_total_apply_use_resource_->::alproto::ApplyAndUseResourceInfo::Clear();
  clear_has_instance_total_apply_use_resource();
}
inline const ::alproto::ApplyAndUseResourceInfo& FrameworkInstanceResourceInfo::instance_total_apply_use_resource() const {
  return instance_total_apply_use_resource_ != NULL ? *instance_total_apply_use_resource_ : *default_instance_->instance_total_apply_use_resource_;
}
inline ::alproto::ApplyAndUseResourceInfo* FrameworkInstanceResourceInfo::mutable_instance_total_apply_use_resource() {
  set_has_instance_total_apply_use_resource();
  if (instance_total_apply_use_resource_ == NULL) instance_total_apply_use_resource_ = new ::alproto::ApplyAndUseResourceInfo;
  return instance_total_apply_use_resource_;
}
inline ::alproto::ApplyAndUseResourceInfo* FrameworkInstanceResourceInfo::release_instance_total_apply_use_resource() {
  clear_has_instance_total_apply_use_resource();
  ::alproto::ApplyAndUseResourceInfo* temp = instance_total_apply_use_resource_;
  instance_total_apply_use_resource_ = NULL;
  return temp;
}

// repeated .alproto.MachineInstanceResourceInfo instance_at_machine_resource = 2;
inline int FrameworkInstanceResourceInfo::instance_at_machine_resource_size() const {
  return instance_at_machine_resource_.size();
}
inline void FrameworkInstanceResourceInfo::clear_instance_at_machine_resource() {
  instance_at_machine_resource_.Clear();
}
inline const ::alproto::MachineInstanceResourceInfo& FrameworkInstanceResourceInfo::instance_at_machine_resource(int index) const {
  return instance_at_machine_resource_.Get(index);
}
inline ::alproto::MachineInstanceResourceInfo* FrameworkInstanceResourceInfo::mutable_instance_at_machine_resource(int index) {
  return instance_at_machine_resource_.Mutable(index);
}
inline ::alproto::MachineInstanceResourceInfo* FrameworkInstanceResourceInfo::add_instance_at_machine_resource() {
  return instance_at_machine_resource_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::alproto::MachineInstanceResourceInfo >&
FrameworkInstanceResourceInfo::instance_at_machine_resource() const {
  return instance_at_machine_resource_;
}
inline ::google::protobuf::RepeatedPtrField< ::alproto::MachineInstanceResourceInfo >*
FrameworkInstanceResourceInfo::mutable_instance_at_machine_resource() {
  return &instance_at_machine_resource_;
}

// repeated .alproto.InstanceMachineResourceInfo machine_has_instance_resource = 3;
inline int FrameworkInstanceResourceInfo::machine_has_instance_resource_size() const {
  return machine_has_instance_resource_.size();
}
inline void FrameworkInstanceResourceInfo::clear_machine_has_instance_resource() {
  machine_has_instance_resource_.Clear();
}
inline const ::alproto::InstanceMachineResourceInfo& FrameworkInstanceResourceInfo::machine_has_instance_resource(int index) const {
  return machine_has_instance_resource_.Get(index);
}
inline ::alproto::InstanceMachineResourceInfo* FrameworkInstanceResourceInfo::mutable_machine_has_instance_resource(int index) {
  return machine_has_instance_resource_.Mutable(index);
}
inline ::alproto::InstanceMachineResourceInfo* FrameworkInstanceResourceInfo::add_machine_has_instance_resource() {
  return machine_has_instance_resource_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::alproto::InstanceMachineResourceInfo >&
FrameworkInstanceResourceInfo::machine_has_instance_resource() const {
  return machine_has_instance_resource_;
}
inline ::google::protobuf::RepeatedPtrField< ::alproto::InstanceMachineResourceInfo >*
FrameworkInstanceResourceInfo::mutable_machine_has_instance_resource() {
  return &machine_has_instance_resource_;
}

// -------------------------------------------------------------------

// NetworkAddress

// required string node_ip = 1;
inline bool NetworkAddress::has_node_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NetworkAddress::set_has_node_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NetworkAddress::clear_has_node_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NetworkAddress::clear_node_ip() {
  if (node_ip_ != &::google::protobuf::internal::kEmptyString) {
    node_ip_->clear();
  }
  clear_has_node_ip();
}
inline const ::std::string& NetworkAddress::node_ip() const {
  return *node_ip_;
}
inline void NetworkAddress::set_node_ip(const ::std::string& value) {
  set_has_node_ip();
  if (node_ip_ == &::google::protobuf::internal::kEmptyString) {
    node_ip_ = new ::std::string;
  }
  node_ip_->assign(value);
}
inline void NetworkAddress::set_node_ip(const char* value) {
  set_has_node_ip();
  if (node_ip_ == &::google::protobuf::internal::kEmptyString) {
    node_ip_ = new ::std::string;
  }
  node_ip_->assign(value);
}
inline void NetworkAddress::set_node_ip(const char* value, size_t size) {
  set_has_node_ip();
  if (node_ip_ == &::google::protobuf::internal::kEmptyString) {
    node_ip_ = new ::std::string;
  }
  node_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NetworkAddress::mutable_node_ip() {
  set_has_node_ip();
  if (node_ip_ == &::google::protobuf::internal::kEmptyString) {
    node_ip_ = new ::std::string;
  }
  return node_ip_;
}
inline ::std::string* NetworkAddress::release_node_ip() {
  clear_has_node_ip();
  if (node_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = node_ip_;
    node_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 node_port = 2;
inline bool NetworkAddress::has_node_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NetworkAddress::set_has_node_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NetworkAddress::clear_has_node_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NetworkAddress::clear_node_port() {
  node_port_ = 0u;
  clear_has_node_port();
}
inline ::google::protobuf::uint32 NetworkAddress::node_port() const {
  return node_port_;
}
inline void NetworkAddress::set_node_port(::google::protobuf::uint32 value) {
  set_has_node_port();
  node_port_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace alproto

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ALProtocol_2eproto__INCLUDED
