// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: FwmNcProtocol.proto

#ifndef PROTOBUF_FwmNcProtocol_2eproto__INCLUDED
#define PROTOBUF_FwmNcProtocol_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace FwmNcProto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_FwmNcProtocol_2eproto();
void protobuf_AssignDesc_FwmNcProtocol_2eproto();
void protobuf_ShutdownFile_FwmNcProtocol_2eproto();

class GpuResourceInfo;
class ResourceInfo;
class FrameworkInstanceInfo;
class FrameworkResourceInfo;
class DockerImageInfo;
class NetAddress;
class StartSlave;
class RespondStartSlave;

// ===================================================================

class GpuResourceInfo : public ::google::protobuf::Message {
 public:
  GpuResourceInfo();
  virtual ~GpuResourceInfo();
  
  GpuResourceInfo(const GpuResourceInfo& from);
  
  inline GpuResourceInfo& operator=(const GpuResourceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GpuResourceInfo& default_instance();
  
  void Swap(GpuResourceInfo* other);
  
  // implements Message ----------------------------------------------
  
  GpuResourceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GpuResourceInfo& from);
  void MergeFrom(const GpuResourceInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string gpu_name = 1;
  inline bool has_gpu_name() const;
  inline void clear_gpu_name();
  static const int kGpuNameFieldNumber = 1;
  inline const ::std::string& gpu_name() const;
  inline void set_gpu_name(const ::std::string& value);
  inline void set_gpu_name(const char* value);
  inline void set_gpu_name(const char* value, size_t size);
  inline ::std::string* mutable_gpu_name();
  inline ::std::string* release_gpu_name();
  
  // optional uint32 gpu_mem_size = 2;
  inline bool has_gpu_mem_size() const;
  inline void clear_gpu_mem_size();
  static const int kGpuMemSizeFieldNumber = 2;
  inline ::google::protobuf::uint32 gpu_mem_size() const;
  inline void set_gpu_mem_size(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:FwmNcProto.GpuResourceInfo)
 private:
  inline void set_has_gpu_name();
  inline void clear_has_gpu_name();
  inline void set_has_gpu_mem_size();
  inline void clear_has_gpu_mem_size();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* gpu_name_;
  ::google::protobuf::uint32 gpu_mem_size_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_FwmNcProtocol_2eproto();
  friend void protobuf_AssignDesc_FwmNcProtocol_2eproto();
  friend void protobuf_ShutdownFile_FwmNcProtocol_2eproto();
  
  void InitAsDefaultInstance();
  static GpuResourceInfo* default_instance_;
};
// -------------------------------------------------------------------

class ResourceInfo : public ::google::protobuf::Message {
 public:
  ResourceInfo();
  virtual ~ResourceInfo();
  
  ResourceInfo(const ResourceInfo& from);
  
  inline ResourceInfo& operator=(const ResourceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResourceInfo& default_instance();
  
  void Swap(ResourceInfo* other);
  
  // implements Message ----------------------------------------------
  
  ResourceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResourceInfo& from);
  void MergeFrom(const ResourceInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required double cpu_num = 1;
  inline bool has_cpu_num() const;
  inline void clear_cpu_num();
  static const int kCpuNumFieldNumber = 1;
  inline double cpu_num() const;
  inline void set_cpu_num(double value);
  
  // required uint32 cpu_mem_size = 2;
  inline bool has_cpu_mem_size() const;
  inline void clear_cpu_mem_size();
  static const int kCpuMemSizeFieldNumber = 2;
  inline ::google::protobuf::uint32 cpu_mem_size() const;
  inline void set_cpu_mem_size(::google::protobuf::uint32 value);
  
  // optional uint32 gpu_num = 3;
  inline bool has_gpu_num() const;
  inline void clear_gpu_num();
  static const int kGpuNumFieldNumber = 3;
  inline ::google::protobuf::uint32 gpu_num() const;
  inline void set_gpu_num(::google::protobuf::uint32 value);
  
  // repeated .FwmNcProto.GpuResourceInfo gpu_resource_info = 4;
  inline int gpu_resource_info_size() const;
  inline void clear_gpu_resource_info();
  static const int kGpuResourceInfoFieldNumber = 4;
  inline const ::FwmNcProto::GpuResourceInfo& gpu_resource_info(int index) const;
  inline ::FwmNcProto::GpuResourceInfo* mutable_gpu_resource_info(int index);
  inline ::FwmNcProto::GpuResourceInfo* add_gpu_resource_info();
  inline const ::google::protobuf::RepeatedPtrField< ::FwmNcProto::GpuResourceInfo >&
      gpu_resource_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::FwmNcProto::GpuResourceInfo >*
      mutable_gpu_resource_info();
  
  // @@protoc_insertion_point(class_scope:FwmNcProto.ResourceInfo)
 private:
  inline void set_has_cpu_num();
  inline void clear_has_cpu_num();
  inline void set_has_cpu_mem_size();
  inline void clear_has_cpu_mem_size();
  inline void set_has_gpu_num();
  inline void clear_has_gpu_num();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  double cpu_num_;
  ::google::protobuf::uint32 cpu_mem_size_;
  ::google::protobuf::uint32 gpu_num_;
  ::google::protobuf::RepeatedPtrField< ::FwmNcProto::GpuResourceInfo > gpu_resource_info_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_FwmNcProtocol_2eproto();
  friend void protobuf_AssignDesc_FwmNcProtocol_2eproto();
  friend void protobuf_ShutdownFile_FwmNcProtocol_2eproto();
  
  void InitAsDefaultInstance();
  static ResourceInfo* default_instance_;
};
// -------------------------------------------------------------------

class FrameworkInstanceInfo : public ::google::protobuf::Message {
 public:
  FrameworkInstanceInfo();
  virtual ~FrameworkInstanceInfo();
  
  FrameworkInstanceInfo(const FrameworkInstanceInfo& from);
  
  inline FrameworkInstanceInfo& operator=(const FrameworkInstanceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FrameworkInstanceInfo& default_instance();
  
  void Swap(FrameworkInstanceInfo* other);
  
  // implements Message ----------------------------------------------
  
  FrameworkInstanceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FrameworkInstanceInfo& from);
  void MergeFrom(const FrameworkInstanceInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 framework_id = 1;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 1;
  inline ::google::protobuf::uint32 framework_id() const;
  inline void set_framework_id(::google::protobuf::uint32 value);
  
  // required uint32 framework_instance_id = 2;
  inline bool has_framework_instance_id() const;
  inline void clear_framework_instance_id();
  static const int kFrameworkInstanceIdFieldNumber = 2;
  inline ::google::protobuf::uint32 framework_instance_id() const;
  inline void set_framework_instance_id(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:FwmNcProto.FrameworkInstanceInfo)
 private:
  inline void set_has_framework_id();
  inline void clear_has_framework_id();
  inline void set_has_framework_instance_id();
  inline void clear_has_framework_instance_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 framework_id_;
  ::google::protobuf::uint32 framework_instance_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_FwmNcProtocol_2eproto();
  friend void protobuf_AssignDesc_FwmNcProtocol_2eproto();
  friend void protobuf_ShutdownFile_FwmNcProtocol_2eproto();
  
  void InitAsDefaultInstance();
  static FrameworkInstanceInfo* default_instance_;
};
// -------------------------------------------------------------------

class FrameworkResourceInfo : public ::google::protobuf::Message {
 public:
  FrameworkResourceInfo();
  virtual ~FrameworkResourceInfo();
  
  FrameworkResourceInfo(const FrameworkResourceInfo& from);
  
  inline FrameworkResourceInfo& operator=(const FrameworkResourceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FrameworkResourceInfo& default_instance();
  
  void Swap(FrameworkResourceInfo* other);
  
  // implements Message ----------------------------------------------
  
  FrameworkResourceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FrameworkResourceInfo& from);
  void MergeFrom(const FrameworkResourceInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .FwmNcProto.FrameworkInstanceInfo framework_instance_info = 1;
  inline bool has_framework_instance_info() const;
  inline void clear_framework_instance_info();
  static const int kFrameworkInstanceInfoFieldNumber = 1;
  inline const ::FwmNcProto::FrameworkInstanceInfo& framework_instance_info() const;
  inline ::FwmNcProto::FrameworkInstanceInfo* mutable_framework_instance_info();
  inline ::FwmNcProto::FrameworkInstanceInfo* release_framework_instance_info();
  
  // optional .FwmNcProto.ResourceInfo resource_info = 2;
  inline bool has_resource_info() const;
  inline void clear_resource_info();
  static const int kResourceInfoFieldNumber = 2;
  inline const ::FwmNcProto::ResourceInfo& resource_info() const;
  inline ::FwmNcProto::ResourceInfo* mutable_resource_info();
  inline ::FwmNcProto::ResourceInfo* release_resource_info();
  
  // optional uint32 module_PID = 3;
  inline bool has_module_pid() const;
  inline void clear_module_pid();
  static const int kModulePIDFieldNumber = 3;
  inline ::google::protobuf::uint32 module_pid() const;
  inline void set_module_pid(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:FwmNcProto.FrameworkResourceInfo)
 private:
  inline void set_has_framework_instance_info();
  inline void clear_has_framework_instance_info();
  inline void set_has_resource_info();
  inline void clear_has_resource_info();
  inline void set_has_module_pid();
  inline void clear_has_module_pid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::FwmNcProto::FrameworkInstanceInfo* framework_instance_info_;
  ::FwmNcProto::ResourceInfo* resource_info_;
  ::google::protobuf::uint32 module_pid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_FwmNcProtocol_2eproto();
  friend void protobuf_AssignDesc_FwmNcProtocol_2eproto();
  friend void protobuf_ShutdownFile_FwmNcProtocol_2eproto();
  
  void InitAsDefaultInstance();
  static FrameworkResourceInfo* default_instance_;
};
// -------------------------------------------------------------------

class DockerImageInfo : public ::google::protobuf::Message {
 public:
  DockerImageInfo();
  virtual ~DockerImageInfo();
  
  DockerImageInfo(const DockerImageInfo& from);
  
  inline DockerImageInfo& operator=(const DockerImageInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DockerImageInfo& default_instance();
  
  void Swap(DockerImageInfo* other);
  
  // implements Message ----------------------------------------------
  
  DockerImageInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DockerImageInfo& from);
  void MergeFrom(const DockerImageInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string tag = 1;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 1;
  inline const ::std::string& tag() const;
  inline void set_tag(const ::std::string& value);
  inline void set_tag(const char* value);
  inline void set_tag(const char* value, size_t size);
  inline ::std::string* mutable_tag();
  inline ::std::string* release_tag();
  
  // optional string locate_file = 2;
  inline bool has_locate_file() const;
  inline void clear_locate_file();
  static const int kLocateFileFieldNumber = 2;
  inline const ::std::string& locate_file() const;
  inline void set_locate_file(const ::std::string& value);
  inline void set_locate_file(const char* value);
  inline void set_locate_file(const char* value, size_t size);
  inline ::std::string* mutable_locate_file();
  inline ::std::string* release_locate_file();
  
  // optional string module_name = 3;
  inline bool has_module_name() const;
  inline void clear_module_name();
  static const int kModuleNameFieldNumber = 3;
  inline const ::std::string& module_name() const;
  inline void set_module_name(const ::std::string& value);
  inline void set_module_name(const char* value);
  inline void set_module_name(const char* value, size_t size);
  inline ::std::string* mutable_module_name();
  inline ::std::string* release_module_name();
  
  // @@protoc_insertion_point(class_scope:FwmNcProto.DockerImageInfo)
 private:
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_locate_file();
  inline void clear_has_locate_file();
  inline void set_has_module_name();
  inline void clear_has_module_name();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* tag_;
  ::std::string* locate_file_;
  ::std::string* module_name_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_FwmNcProtocol_2eproto();
  friend void protobuf_AssignDesc_FwmNcProtocol_2eproto();
  friend void protobuf_ShutdownFile_FwmNcProtocol_2eproto();
  
  void InitAsDefaultInstance();
  static DockerImageInfo* default_instance_;
};
// -------------------------------------------------------------------

class NetAddress : public ::google::protobuf::Message {
 public:
  NetAddress();
  virtual ~NetAddress();
  
  NetAddress(const NetAddress& from);
  
  inline NetAddress& operator=(const NetAddress& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NetAddress& default_instance();
  
  void Swap(NetAddress* other);
  
  // implements Message ----------------------------------------------
  
  NetAddress* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NetAddress& from);
  void MergeFrom(const NetAddress& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  
  // optional uint32 port = 2;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:FwmNcProto.NetAddress)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* ip_;
  ::google::protobuf::uint32 port_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_FwmNcProtocol_2eproto();
  friend void protobuf_AssignDesc_FwmNcProtocol_2eproto();
  friend void protobuf_ShutdownFile_FwmNcProtocol_2eproto();
  
  void InitAsDefaultInstance();
  static NetAddress* default_instance_;
};
// -------------------------------------------------------------------

class StartSlave : public ::google::protobuf::Message {
 public:
  StartSlave();
  virtual ~StartSlave();
  
  StartSlave(const StartSlave& from);
  
  inline StartSlave& operator=(const StartSlave& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StartSlave& default_instance();
  
  void Swap(StartSlave* other);
  
  // implements Message ----------------------------------------------
  
  StartSlave* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StartSlave& from);
  void MergeFrom(const StartSlave& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .FwmNcProto.FrameworkInstanceInfo framework_instance_info = 1;
  inline bool has_framework_instance_info() const;
  inline void clear_framework_instance_info();
  static const int kFrameworkInstanceInfoFieldNumber = 1;
  inline const ::FwmNcProto::FrameworkInstanceInfo& framework_instance_info() const;
  inline ::FwmNcProto::FrameworkInstanceInfo* mutable_framework_instance_info();
  inline ::FwmNcProto::FrameworkInstanceInfo* release_framework_instance_info();
  
  // optional .FwmNcProto.DockerImageInfo docker_image_info = 2;
  inline bool has_docker_image_info() const;
  inline void clear_docker_image_info();
  static const int kDockerImageInfoFieldNumber = 2;
  inline const ::FwmNcProto::DockerImageInfo& docker_image_info() const;
  inline ::FwmNcProto::DockerImageInfo* mutable_docker_image_info();
  inline ::FwmNcProto::DockerImageInfo* release_docker_image_info();
  
  // optional .FwmNcProto.ResourceInfo resource_info = 3;
  inline bool has_resource_info() const;
  inline void clear_resource_info();
  static const int kResourceInfoFieldNumber = 3;
  inline const ::FwmNcProto::ResourceInfo& resource_info() const;
  inline ::FwmNcProto::ResourceInfo* mutable_resource_info();
  inline ::FwmNcProto::ResourceInfo* release_resource_info();
  
  // optional uint32 listen_port_num = 4;
  inline bool has_listen_port_num() const;
  inline void clear_listen_port_num();
  static const int kListenPortNumFieldNumber = 4;
  inline ::google::protobuf::uint32 listen_port_num() const;
  inline void set_listen_port_num(::google::protobuf::uint32 value);
  
  // optional .FwmNcProto.NetAddress FM_master_net_address = 5;
  inline bool has_fm_master_net_address() const;
  inline void clear_fm_master_net_address();
  static const int kFMMasterNetAddressFieldNumber = 5;
  inline const ::FwmNcProto::NetAddress& fm_master_net_address() const;
  inline ::FwmNcProto::NetAddress* mutable_fm_master_net_address();
  inline ::FwmNcProto::NetAddress* release_fm_master_net_address();
  
  // @@protoc_insertion_point(class_scope:FwmNcProto.StartSlave)
 private:
  inline void set_has_framework_instance_info();
  inline void clear_has_framework_instance_info();
  inline void set_has_docker_image_info();
  inline void clear_has_docker_image_info();
  inline void set_has_resource_info();
  inline void clear_has_resource_info();
  inline void set_has_listen_port_num();
  inline void clear_has_listen_port_num();
  inline void set_has_fm_master_net_address();
  inline void clear_has_fm_master_net_address();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::FwmNcProto::FrameworkInstanceInfo* framework_instance_info_;
  ::FwmNcProto::DockerImageInfo* docker_image_info_;
  ::FwmNcProto::ResourceInfo* resource_info_;
  ::FwmNcProto::NetAddress* fm_master_net_address_;
  ::google::protobuf::uint32 listen_port_num_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_FwmNcProtocol_2eproto();
  friend void protobuf_AssignDesc_FwmNcProtocol_2eproto();
  friend void protobuf_ShutdownFile_FwmNcProtocol_2eproto();
  
  void InitAsDefaultInstance();
  static StartSlave* default_instance_;
};
// -------------------------------------------------------------------

class RespondStartSlave : public ::google::protobuf::Message {
 public:
  RespondStartSlave();
  virtual ~RespondStartSlave();
  
  RespondStartSlave(const RespondStartSlave& from);
  
  inline RespondStartSlave& operator=(const RespondStartSlave& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RespondStartSlave& default_instance();
  
  void Swap(RespondStartSlave* other);
  
  // implements Message ----------------------------------------------
  
  RespondStartSlave* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RespondStartSlave& from);
  void MergeFrom(const RespondStartSlave& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .FwmNcProto.FrameworkInstanceInfo framework_instance_info = 1;
  inline bool has_framework_instance_info() const;
  inline void clear_framework_instance_info();
  static const int kFrameworkInstanceInfoFieldNumber = 1;
  inline const ::FwmNcProto::FrameworkInstanceInfo& framework_instance_info() const;
  inline ::FwmNcProto::FrameworkInstanceInfo* mutable_framework_instance_info();
  inline ::FwmNcProto::FrameworkInstanceInfo* release_framework_instance_info();
  
  // optional string machine_ip = 2;
  inline bool has_machine_ip() const;
  inline void clear_machine_ip();
  static const int kMachineIpFieldNumber = 2;
  inline const ::std::string& machine_ip() const;
  inline void set_machine_ip(const ::std::string& value);
  inline void set_machine_ip(const char* value);
  inline void set_machine_ip(const char* value, size_t size);
  inline ::std::string* mutable_machine_ip();
  inline ::std::string* release_machine_ip();
  
  // optional uint32 module_PID = 3;
  inline bool has_module_pid() const;
  inline void clear_module_pid();
  static const int kModulePIDFieldNumber = 3;
  inline ::google::protobuf::uint32 module_pid() const;
  inline void set_module_pid(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:FwmNcProto.RespondStartSlave)
 private:
  inline void set_has_framework_instance_info();
  inline void clear_has_framework_instance_info();
  inline void set_has_machine_ip();
  inline void clear_has_machine_ip();
  inline void set_has_module_pid();
  inline void clear_has_module_pid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::FwmNcProto::FrameworkInstanceInfo* framework_instance_info_;
  ::std::string* machine_ip_;
  ::google::protobuf::uint32 module_pid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_FwmNcProtocol_2eproto();
  friend void protobuf_AssignDesc_FwmNcProtocol_2eproto();
  friend void protobuf_ShutdownFile_FwmNcProtocol_2eproto();
  
  void InitAsDefaultInstance();
  static RespondStartSlave* default_instance_;
};
// ===================================================================


// ===================================================================

// GpuResourceInfo

// required string gpu_name = 1;
inline bool GpuResourceInfo::has_gpu_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GpuResourceInfo::set_has_gpu_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GpuResourceInfo::clear_has_gpu_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GpuResourceInfo::clear_gpu_name() {
  if (gpu_name_ != &::google::protobuf::internal::kEmptyString) {
    gpu_name_->clear();
  }
  clear_has_gpu_name();
}
inline const ::std::string& GpuResourceInfo::gpu_name() const {
  return *gpu_name_;
}
inline void GpuResourceInfo::set_gpu_name(const ::std::string& value) {
  set_has_gpu_name();
  if (gpu_name_ == &::google::protobuf::internal::kEmptyString) {
    gpu_name_ = new ::std::string;
  }
  gpu_name_->assign(value);
}
inline void GpuResourceInfo::set_gpu_name(const char* value) {
  set_has_gpu_name();
  if (gpu_name_ == &::google::protobuf::internal::kEmptyString) {
    gpu_name_ = new ::std::string;
  }
  gpu_name_->assign(value);
}
inline void GpuResourceInfo::set_gpu_name(const char* value, size_t size) {
  set_has_gpu_name();
  if (gpu_name_ == &::google::protobuf::internal::kEmptyString) {
    gpu_name_ = new ::std::string;
  }
  gpu_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GpuResourceInfo::mutable_gpu_name() {
  set_has_gpu_name();
  if (gpu_name_ == &::google::protobuf::internal::kEmptyString) {
    gpu_name_ = new ::std::string;
  }
  return gpu_name_;
}
inline ::std::string* GpuResourceInfo::release_gpu_name() {
  clear_has_gpu_name();
  if (gpu_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gpu_name_;
    gpu_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 gpu_mem_size = 2;
inline bool GpuResourceInfo::has_gpu_mem_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GpuResourceInfo::set_has_gpu_mem_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GpuResourceInfo::clear_has_gpu_mem_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GpuResourceInfo::clear_gpu_mem_size() {
  gpu_mem_size_ = 0u;
  clear_has_gpu_mem_size();
}
inline ::google::protobuf::uint32 GpuResourceInfo::gpu_mem_size() const {
  return gpu_mem_size_;
}
inline void GpuResourceInfo::set_gpu_mem_size(::google::protobuf::uint32 value) {
  set_has_gpu_mem_size();
  gpu_mem_size_ = value;
}

// -------------------------------------------------------------------

// ResourceInfo

// required double cpu_num = 1;
inline bool ResourceInfo::has_cpu_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResourceInfo::set_has_cpu_num() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResourceInfo::clear_has_cpu_num() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResourceInfo::clear_cpu_num() {
  cpu_num_ = 0;
  clear_has_cpu_num();
}
inline double ResourceInfo::cpu_num() const {
  return cpu_num_;
}
inline void ResourceInfo::set_cpu_num(double value) {
  set_has_cpu_num();
  cpu_num_ = value;
}

// required uint32 cpu_mem_size = 2;
inline bool ResourceInfo::has_cpu_mem_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResourceInfo::set_has_cpu_mem_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResourceInfo::clear_has_cpu_mem_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResourceInfo::clear_cpu_mem_size() {
  cpu_mem_size_ = 0u;
  clear_has_cpu_mem_size();
}
inline ::google::protobuf::uint32 ResourceInfo::cpu_mem_size() const {
  return cpu_mem_size_;
}
inline void ResourceInfo::set_cpu_mem_size(::google::protobuf::uint32 value) {
  set_has_cpu_mem_size();
  cpu_mem_size_ = value;
}

// optional uint32 gpu_num = 3;
inline bool ResourceInfo::has_gpu_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResourceInfo::set_has_gpu_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResourceInfo::clear_has_gpu_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResourceInfo::clear_gpu_num() {
  gpu_num_ = 0u;
  clear_has_gpu_num();
}
inline ::google::protobuf::uint32 ResourceInfo::gpu_num() const {
  return gpu_num_;
}
inline void ResourceInfo::set_gpu_num(::google::protobuf::uint32 value) {
  set_has_gpu_num();
  gpu_num_ = value;
}

// repeated .FwmNcProto.GpuResourceInfo gpu_resource_info = 4;
inline int ResourceInfo::gpu_resource_info_size() const {
  return gpu_resource_info_.size();
}
inline void ResourceInfo::clear_gpu_resource_info() {
  gpu_resource_info_.Clear();
}
inline const ::FwmNcProto::GpuResourceInfo& ResourceInfo::gpu_resource_info(int index) const {
  return gpu_resource_info_.Get(index);
}
inline ::FwmNcProto::GpuResourceInfo* ResourceInfo::mutable_gpu_resource_info(int index) {
  return gpu_resource_info_.Mutable(index);
}
inline ::FwmNcProto::GpuResourceInfo* ResourceInfo::add_gpu_resource_info() {
  return gpu_resource_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FwmNcProto::GpuResourceInfo >&
ResourceInfo::gpu_resource_info() const {
  return gpu_resource_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::FwmNcProto::GpuResourceInfo >*
ResourceInfo::mutable_gpu_resource_info() {
  return &gpu_resource_info_;
}

// -------------------------------------------------------------------

// FrameworkInstanceInfo

// required uint32 framework_id = 1;
inline bool FrameworkInstanceInfo::has_framework_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FrameworkInstanceInfo::set_has_framework_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FrameworkInstanceInfo::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FrameworkInstanceInfo::clear_framework_id() {
  framework_id_ = 0u;
  clear_has_framework_id();
}
inline ::google::protobuf::uint32 FrameworkInstanceInfo::framework_id() const {
  return framework_id_;
}
inline void FrameworkInstanceInfo::set_framework_id(::google::protobuf::uint32 value) {
  set_has_framework_id();
  framework_id_ = value;
}

// required uint32 framework_instance_id = 2;
inline bool FrameworkInstanceInfo::has_framework_instance_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FrameworkInstanceInfo::set_has_framework_instance_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FrameworkInstanceInfo::clear_has_framework_instance_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FrameworkInstanceInfo::clear_framework_instance_id() {
  framework_instance_id_ = 0u;
  clear_has_framework_instance_id();
}
inline ::google::protobuf::uint32 FrameworkInstanceInfo::framework_instance_id() const {
  return framework_instance_id_;
}
inline void FrameworkInstanceInfo::set_framework_instance_id(::google::protobuf::uint32 value) {
  set_has_framework_instance_id();
  framework_instance_id_ = value;
}

// -------------------------------------------------------------------

// FrameworkResourceInfo

// required .FwmNcProto.FrameworkInstanceInfo framework_instance_info = 1;
inline bool FrameworkResourceInfo::has_framework_instance_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FrameworkResourceInfo::set_has_framework_instance_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FrameworkResourceInfo::clear_has_framework_instance_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FrameworkResourceInfo::clear_framework_instance_info() {
  if (framework_instance_info_ != NULL) framework_instance_info_->::FwmNcProto::FrameworkInstanceInfo::Clear();
  clear_has_framework_instance_info();
}
inline const ::FwmNcProto::FrameworkInstanceInfo& FrameworkResourceInfo::framework_instance_info() const {
  return framework_instance_info_ != NULL ? *framework_instance_info_ : *default_instance_->framework_instance_info_;
}
inline ::FwmNcProto::FrameworkInstanceInfo* FrameworkResourceInfo::mutable_framework_instance_info() {
  set_has_framework_instance_info();
  if (framework_instance_info_ == NULL) framework_instance_info_ = new ::FwmNcProto::FrameworkInstanceInfo;
  return framework_instance_info_;
}
inline ::FwmNcProto::FrameworkInstanceInfo* FrameworkResourceInfo::release_framework_instance_info() {
  clear_has_framework_instance_info();
  ::FwmNcProto::FrameworkInstanceInfo* temp = framework_instance_info_;
  framework_instance_info_ = NULL;
  return temp;
}

// optional .FwmNcProto.ResourceInfo resource_info = 2;
inline bool FrameworkResourceInfo::has_resource_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FrameworkResourceInfo::set_has_resource_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FrameworkResourceInfo::clear_has_resource_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FrameworkResourceInfo::clear_resource_info() {
  if (resource_info_ != NULL) resource_info_->::FwmNcProto::ResourceInfo::Clear();
  clear_has_resource_info();
}
inline const ::FwmNcProto::ResourceInfo& FrameworkResourceInfo::resource_info() const {
  return resource_info_ != NULL ? *resource_info_ : *default_instance_->resource_info_;
}
inline ::FwmNcProto::ResourceInfo* FrameworkResourceInfo::mutable_resource_info() {
  set_has_resource_info();
  if (resource_info_ == NULL) resource_info_ = new ::FwmNcProto::ResourceInfo;
  return resource_info_;
}
inline ::FwmNcProto::ResourceInfo* FrameworkResourceInfo::release_resource_info() {
  clear_has_resource_info();
  ::FwmNcProto::ResourceInfo* temp = resource_info_;
  resource_info_ = NULL;
  return temp;
}

// optional uint32 module_PID = 3;
inline bool FrameworkResourceInfo::has_module_pid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FrameworkResourceInfo::set_has_module_pid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FrameworkResourceInfo::clear_has_module_pid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FrameworkResourceInfo::clear_module_pid() {
  module_pid_ = 0u;
  clear_has_module_pid();
}
inline ::google::protobuf::uint32 FrameworkResourceInfo::module_pid() const {
  return module_pid_;
}
inline void FrameworkResourceInfo::set_module_pid(::google::protobuf::uint32 value) {
  set_has_module_pid();
  module_pid_ = value;
}

// -------------------------------------------------------------------

// DockerImageInfo

// required string tag = 1;
inline bool DockerImageInfo::has_tag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DockerImageInfo::set_has_tag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DockerImageInfo::clear_has_tag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DockerImageInfo::clear_tag() {
  if (tag_ != &::google::protobuf::internal::kEmptyString) {
    tag_->clear();
  }
  clear_has_tag();
}
inline const ::std::string& DockerImageInfo::tag() const {
  return *tag_;
}
inline void DockerImageInfo::set_tag(const ::std::string& value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void DockerImageInfo::set_tag(const char* value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void DockerImageInfo::set_tag(const char* value, size_t size) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DockerImageInfo::mutable_tag() {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  return tag_;
}
inline ::std::string* DockerImageInfo::release_tag() {
  clear_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tag_;
    tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string locate_file = 2;
inline bool DockerImageInfo::has_locate_file() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DockerImageInfo::set_has_locate_file() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DockerImageInfo::clear_has_locate_file() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DockerImageInfo::clear_locate_file() {
  if (locate_file_ != &::google::protobuf::internal::kEmptyString) {
    locate_file_->clear();
  }
  clear_has_locate_file();
}
inline const ::std::string& DockerImageInfo::locate_file() const {
  return *locate_file_;
}
inline void DockerImageInfo::set_locate_file(const ::std::string& value) {
  set_has_locate_file();
  if (locate_file_ == &::google::protobuf::internal::kEmptyString) {
    locate_file_ = new ::std::string;
  }
  locate_file_->assign(value);
}
inline void DockerImageInfo::set_locate_file(const char* value) {
  set_has_locate_file();
  if (locate_file_ == &::google::protobuf::internal::kEmptyString) {
    locate_file_ = new ::std::string;
  }
  locate_file_->assign(value);
}
inline void DockerImageInfo::set_locate_file(const char* value, size_t size) {
  set_has_locate_file();
  if (locate_file_ == &::google::protobuf::internal::kEmptyString) {
    locate_file_ = new ::std::string;
  }
  locate_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DockerImageInfo::mutable_locate_file() {
  set_has_locate_file();
  if (locate_file_ == &::google::protobuf::internal::kEmptyString) {
    locate_file_ = new ::std::string;
  }
  return locate_file_;
}
inline ::std::string* DockerImageInfo::release_locate_file() {
  clear_has_locate_file();
  if (locate_file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = locate_file_;
    locate_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string module_name = 3;
inline bool DockerImageInfo::has_module_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DockerImageInfo::set_has_module_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DockerImageInfo::clear_has_module_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DockerImageInfo::clear_module_name() {
  if (module_name_ != &::google::protobuf::internal::kEmptyString) {
    module_name_->clear();
  }
  clear_has_module_name();
}
inline const ::std::string& DockerImageInfo::module_name() const {
  return *module_name_;
}
inline void DockerImageInfo::set_module_name(const ::std::string& value) {
  set_has_module_name();
  if (module_name_ == &::google::protobuf::internal::kEmptyString) {
    module_name_ = new ::std::string;
  }
  module_name_->assign(value);
}
inline void DockerImageInfo::set_module_name(const char* value) {
  set_has_module_name();
  if (module_name_ == &::google::protobuf::internal::kEmptyString) {
    module_name_ = new ::std::string;
  }
  module_name_->assign(value);
}
inline void DockerImageInfo::set_module_name(const char* value, size_t size) {
  set_has_module_name();
  if (module_name_ == &::google::protobuf::internal::kEmptyString) {
    module_name_ = new ::std::string;
  }
  module_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DockerImageInfo::mutable_module_name() {
  set_has_module_name();
  if (module_name_ == &::google::protobuf::internal::kEmptyString) {
    module_name_ = new ::std::string;
  }
  return module_name_;
}
inline ::std::string* DockerImageInfo::release_module_name() {
  clear_has_module_name();
  if (module_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = module_name_;
    module_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// NetAddress

// required string ip = 1;
inline bool NetAddress::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NetAddress::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NetAddress::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NetAddress::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& NetAddress::ip() const {
  return *ip_;
}
inline void NetAddress::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void NetAddress::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void NetAddress::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NetAddress::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* NetAddress::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 port = 2;
inline bool NetAddress::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NetAddress::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NetAddress::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NetAddress::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 NetAddress::port() const {
  return port_;
}
inline void NetAddress::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// -------------------------------------------------------------------

// StartSlave

// required .FwmNcProto.FrameworkInstanceInfo framework_instance_info = 1;
inline bool StartSlave::has_framework_instance_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StartSlave::set_has_framework_instance_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StartSlave::clear_has_framework_instance_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StartSlave::clear_framework_instance_info() {
  if (framework_instance_info_ != NULL) framework_instance_info_->::FwmNcProto::FrameworkInstanceInfo::Clear();
  clear_has_framework_instance_info();
}
inline const ::FwmNcProto::FrameworkInstanceInfo& StartSlave::framework_instance_info() const {
  return framework_instance_info_ != NULL ? *framework_instance_info_ : *default_instance_->framework_instance_info_;
}
inline ::FwmNcProto::FrameworkInstanceInfo* StartSlave::mutable_framework_instance_info() {
  set_has_framework_instance_info();
  if (framework_instance_info_ == NULL) framework_instance_info_ = new ::FwmNcProto::FrameworkInstanceInfo;
  return framework_instance_info_;
}
inline ::FwmNcProto::FrameworkInstanceInfo* StartSlave::release_framework_instance_info() {
  clear_has_framework_instance_info();
  ::FwmNcProto::FrameworkInstanceInfo* temp = framework_instance_info_;
  framework_instance_info_ = NULL;
  return temp;
}

// optional .FwmNcProto.DockerImageInfo docker_image_info = 2;
inline bool StartSlave::has_docker_image_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StartSlave::set_has_docker_image_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StartSlave::clear_has_docker_image_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StartSlave::clear_docker_image_info() {
  if (docker_image_info_ != NULL) docker_image_info_->::FwmNcProto::DockerImageInfo::Clear();
  clear_has_docker_image_info();
}
inline const ::FwmNcProto::DockerImageInfo& StartSlave::docker_image_info() const {
  return docker_image_info_ != NULL ? *docker_image_info_ : *default_instance_->docker_image_info_;
}
inline ::FwmNcProto::DockerImageInfo* StartSlave::mutable_docker_image_info() {
  set_has_docker_image_info();
  if (docker_image_info_ == NULL) docker_image_info_ = new ::FwmNcProto::DockerImageInfo;
  return docker_image_info_;
}
inline ::FwmNcProto::DockerImageInfo* StartSlave::release_docker_image_info() {
  clear_has_docker_image_info();
  ::FwmNcProto::DockerImageInfo* temp = docker_image_info_;
  docker_image_info_ = NULL;
  return temp;
}

// optional .FwmNcProto.ResourceInfo resource_info = 3;
inline bool StartSlave::has_resource_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StartSlave::set_has_resource_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StartSlave::clear_has_resource_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StartSlave::clear_resource_info() {
  if (resource_info_ != NULL) resource_info_->::FwmNcProto::ResourceInfo::Clear();
  clear_has_resource_info();
}
inline const ::FwmNcProto::ResourceInfo& StartSlave::resource_info() const {
  return resource_info_ != NULL ? *resource_info_ : *default_instance_->resource_info_;
}
inline ::FwmNcProto::ResourceInfo* StartSlave::mutable_resource_info() {
  set_has_resource_info();
  if (resource_info_ == NULL) resource_info_ = new ::FwmNcProto::ResourceInfo;
  return resource_info_;
}
inline ::FwmNcProto::ResourceInfo* StartSlave::release_resource_info() {
  clear_has_resource_info();
  ::FwmNcProto::ResourceInfo* temp = resource_info_;
  resource_info_ = NULL;
  return temp;
}

// optional uint32 listen_port_num = 4;
inline bool StartSlave::has_listen_port_num() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StartSlave::set_has_listen_port_num() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StartSlave::clear_has_listen_port_num() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StartSlave::clear_listen_port_num() {
  listen_port_num_ = 0u;
  clear_has_listen_port_num();
}
inline ::google::protobuf::uint32 StartSlave::listen_port_num() const {
  return listen_port_num_;
}
inline void StartSlave::set_listen_port_num(::google::protobuf::uint32 value) {
  set_has_listen_port_num();
  listen_port_num_ = value;
}

// optional .FwmNcProto.NetAddress FM_master_net_address = 5;
inline bool StartSlave::has_fm_master_net_address() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StartSlave::set_has_fm_master_net_address() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StartSlave::clear_has_fm_master_net_address() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StartSlave::clear_fm_master_net_address() {
  if (fm_master_net_address_ != NULL) fm_master_net_address_->::FwmNcProto::NetAddress::Clear();
  clear_has_fm_master_net_address();
}
inline const ::FwmNcProto::NetAddress& StartSlave::fm_master_net_address() const {
  return fm_master_net_address_ != NULL ? *fm_master_net_address_ : *default_instance_->fm_master_net_address_;
}
inline ::FwmNcProto::NetAddress* StartSlave::mutable_fm_master_net_address() {
  set_has_fm_master_net_address();
  if (fm_master_net_address_ == NULL) fm_master_net_address_ = new ::FwmNcProto::NetAddress;
  return fm_master_net_address_;
}
inline ::FwmNcProto::NetAddress* StartSlave::release_fm_master_net_address() {
  clear_has_fm_master_net_address();
  ::FwmNcProto::NetAddress* temp = fm_master_net_address_;
  fm_master_net_address_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// RespondStartSlave

// required .FwmNcProto.FrameworkInstanceInfo framework_instance_info = 1;
inline bool RespondStartSlave::has_framework_instance_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RespondStartSlave::set_has_framework_instance_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RespondStartSlave::clear_has_framework_instance_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RespondStartSlave::clear_framework_instance_info() {
  if (framework_instance_info_ != NULL) framework_instance_info_->::FwmNcProto::FrameworkInstanceInfo::Clear();
  clear_has_framework_instance_info();
}
inline const ::FwmNcProto::FrameworkInstanceInfo& RespondStartSlave::framework_instance_info() const {
  return framework_instance_info_ != NULL ? *framework_instance_info_ : *default_instance_->framework_instance_info_;
}
inline ::FwmNcProto::FrameworkInstanceInfo* RespondStartSlave::mutable_framework_instance_info() {
  set_has_framework_instance_info();
  if (framework_instance_info_ == NULL) framework_instance_info_ = new ::FwmNcProto::FrameworkInstanceInfo;
  return framework_instance_info_;
}
inline ::FwmNcProto::FrameworkInstanceInfo* RespondStartSlave::release_framework_instance_info() {
  clear_has_framework_instance_info();
  ::FwmNcProto::FrameworkInstanceInfo* temp = framework_instance_info_;
  framework_instance_info_ = NULL;
  return temp;
}

// optional string machine_ip = 2;
inline bool RespondStartSlave::has_machine_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RespondStartSlave::set_has_machine_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RespondStartSlave::clear_has_machine_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RespondStartSlave::clear_machine_ip() {
  if (machine_ip_ != &::google::protobuf::internal::kEmptyString) {
    machine_ip_->clear();
  }
  clear_has_machine_ip();
}
inline const ::std::string& RespondStartSlave::machine_ip() const {
  return *machine_ip_;
}
inline void RespondStartSlave::set_machine_ip(const ::std::string& value) {
  set_has_machine_ip();
  if (machine_ip_ == &::google::protobuf::internal::kEmptyString) {
    machine_ip_ = new ::std::string;
  }
  machine_ip_->assign(value);
}
inline void RespondStartSlave::set_machine_ip(const char* value) {
  set_has_machine_ip();
  if (machine_ip_ == &::google::protobuf::internal::kEmptyString) {
    machine_ip_ = new ::std::string;
  }
  machine_ip_->assign(value);
}
inline void RespondStartSlave::set_machine_ip(const char* value, size_t size) {
  set_has_machine_ip();
  if (machine_ip_ == &::google::protobuf::internal::kEmptyString) {
    machine_ip_ = new ::std::string;
  }
  machine_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RespondStartSlave::mutable_machine_ip() {
  set_has_machine_ip();
  if (machine_ip_ == &::google::protobuf::internal::kEmptyString) {
    machine_ip_ = new ::std::string;
  }
  return machine_ip_;
}
inline ::std::string* RespondStartSlave::release_machine_ip() {
  clear_has_machine_ip();
  if (machine_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = machine_ip_;
    machine_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 module_PID = 3;
inline bool RespondStartSlave::has_module_pid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RespondStartSlave::set_has_module_pid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RespondStartSlave::clear_has_module_pid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RespondStartSlave::clear_module_pid() {
  module_pid_ = 0u;
  clear_has_module_pid();
}
inline ::google::protobuf::uint32 RespondStartSlave::module_pid() const {
  return module_pid_;
}
inline void RespondStartSlave::set_module_pid(::google::protobuf::uint32 value) {
  set_has_module_pid();
  module_pid_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace FwmNcProto

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_FwmNcProtocol_2eproto__INCLUDED
