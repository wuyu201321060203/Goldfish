// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: FwmRcProtocol.proto

#ifndef PROTOBUF_FwmRcProtocol_2eproto__INCLUDED
#define PROTOBUF_FwmRcProtocol_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace FwmRcProto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_FwmRcProtocol_2eproto();
void protobuf_AssignDesc_FwmRcProtocol_2eproto();
void protobuf_ShutdownFile_FwmRcProtocol_2eproto();

class GpuResourceInfo;
class ResourceInfo;
class FrameworkInstanceInfo;
class NetAddress;
class AddressResourceInfo;
class FWMasterInfo;
class FWMRCRegister;
class FWMRCRegisterACK;
class EachMachineResourceInfo;
class RequestSlaveResource;
class EachNCResourceAddress;
class RespondRequestSlaveResource;
class EachSlaveInfo;
class SuccessSlaveInfo;
class RequestTaskResource;
class ResourceAddress;
class RespondRequestTaskResource;
class ReturnTaskResource;
class IPProcessInfo;
class StopModuleInfo;

// ===================================================================

class GpuResourceInfo : public ::google::protobuf::Message {
 public:
  GpuResourceInfo();
  virtual ~GpuResourceInfo();
  
  GpuResourceInfo(const GpuResourceInfo& from);
  
  inline GpuResourceInfo& operator=(const GpuResourceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GpuResourceInfo& default_instance();
  
  void Swap(GpuResourceInfo* other);
  
  // implements Message ----------------------------------------------
  
  GpuResourceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GpuResourceInfo& from);
  void MergeFrom(const GpuResourceInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string gpu_name = 1;
  inline bool has_gpu_name() const;
  inline void clear_gpu_name();
  static const int kGpuNameFieldNumber = 1;
  inline const ::std::string& gpu_name() const;
  inline void set_gpu_name(const ::std::string& value);
  inline void set_gpu_name(const char* value);
  inline void set_gpu_name(const char* value, size_t size);
  inline ::std::string* mutable_gpu_name();
  inline ::std::string* release_gpu_name();
  
  // optional uint32 gpu_mem_size = 2;
  inline bool has_gpu_mem_size() const;
  inline void clear_gpu_mem_size();
  static const int kGpuMemSizeFieldNumber = 2;
  inline ::google::protobuf::uint32 gpu_mem_size() const;
  inline void set_gpu_mem_size(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:FwmRcProto.GpuResourceInfo)
 private:
  inline void set_has_gpu_name();
  inline void clear_has_gpu_name();
  inline void set_has_gpu_mem_size();
  inline void clear_has_gpu_mem_size();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* gpu_name_;
  ::google::protobuf::uint32 gpu_mem_size_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_FwmRcProtocol_2eproto();
  friend void protobuf_AssignDesc_FwmRcProtocol_2eproto();
  friend void protobuf_ShutdownFile_FwmRcProtocol_2eproto();
  
  void InitAsDefaultInstance();
  static GpuResourceInfo* default_instance_;
};
// -------------------------------------------------------------------

class ResourceInfo : public ::google::protobuf::Message {
 public:
  ResourceInfo();
  virtual ~ResourceInfo();
  
  ResourceInfo(const ResourceInfo& from);
  
  inline ResourceInfo& operator=(const ResourceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResourceInfo& default_instance();
  
  void Swap(ResourceInfo* other);
  
  // implements Message ----------------------------------------------
  
  ResourceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResourceInfo& from);
  void MergeFrom(const ResourceInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required double cpu_num = 1;
  inline bool has_cpu_num() const;
  inline void clear_cpu_num();
  static const int kCpuNumFieldNumber = 1;
  inline double cpu_num() const;
  inline void set_cpu_num(double value);
  
  // required uint32 cpu_mem_size = 2;
  inline bool has_cpu_mem_size() const;
  inline void clear_cpu_mem_size();
  static const int kCpuMemSizeFieldNumber = 2;
  inline ::google::protobuf::uint32 cpu_mem_size() const;
  inline void set_cpu_mem_size(::google::protobuf::uint32 value);
  
  // optional uint32 gpu_num = 3;
  inline bool has_gpu_num() const;
  inline void clear_gpu_num();
  static const int kGpuNumFieldNumber = 3;
  inline ::google::protobuf::uint32 gpu_num() const;
  inline void set_gpu_num(::google::protobuf::uint32 value);
  
  // repeated .FwmRcProto.GpuResourceInfo gpu_resource_info = 4;
  inline int gpu_resource_info_size() const;
  inline void clear_gpu_resource_info();
  static const int kGpuResourceInfoFieldNumber = 4;
  inline const ::FwmRcProto::GpuResourceInfo& gpu_resource_info(int index) const;
  inline ::FwmRcProto::GpuResourceInfo* mutable_gpu_resource_info(int index);
  inline ::FwmRcProto::GpuResourceInfo* add_gpu_resource_info();
  inline const ::google::protobuf::RepeatedPtrField< ::FwmRcProto::GpuResourceInfo >&
      gpu_resource_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::FwmRcProto::GpuResourceInfo >*
      mutable_gpu_resource_info();
  
  // @@protoc_insertion_point(class_scope:FwmRcProto.ResourceInfo)
 private:
  inline void set_has_cpu_num();
  inline void clear_has_cpu_num();
  inline void set_has_cpu_mem_size();
  inline void clear_has_cpu_mem_size();
  inline void set_has_gpu_num();
  inline void clear_has_gpu_num();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  double cpu_num_;
  ::google::protobuf::uint32 cpu_mem_size_;
  ::google::protobuf::uint32 gpu_num_;
  ::google::protobuf::RepeatedPtrField< ::FwmRcProto::GpuResourceInfo > gpu_resource_info_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_FwmRcProtocol_2eproto();
  friend void protobuf_AssignDesc_FwmRcProtocol_2eproto();
  friend void protobuf_ShutdownFile_FwmRcProtocol_2eproto();
  
  void InitAsDefaultInstance();
  static ResourceInfo* default_instance_;
};
// -------------------------------------------------------------------

class FrameworkInstanceInfo : public ::google::protobuf::Message {
 public:
  FrameworkInstanceInfo();
  virtual ~FrameworkInstanceInfo();
  
  FrameworkInstanceInfo(const FrameworkInstanceInfo& from);
  
  inline FrameworkInstanceInfo& operator=(const FrameworkInstanceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FrameworkInstanceInfo& default_instance();
  
  void Swap(FrameworkInstanceInfo* other);
  
  // implements Message ----------------------------------------------
  
  FrameworkInstanceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FrameworkInstanceInfo& from);
  void MergeFrom(const FrameworkInstanceInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 framework_id = 1;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 1;
  inline ::google::protobuf::uint32 framework_id() const;
  inline void set_framework_id(::google::protobuf::uint32 value);
  
  // required uint32 framework_instance_id = 2;
  inline bool has_framework_instance_id() const;
  inline void clear_framework_instance_id();
  static const int kFrameworkInstanceIdFieldNumber = 2;
  inline ::google::protobuf::uint32 framework_instance_id() const;
  inline void set_framework_instance_id(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:FwmRcProto.FrameworkInstanceInfo)
 private:
  inline void set_has_framework_id();
  inline void clear_has_framework_id();
  inline void set_has_framework_instance_id();
  inline void clear_has_framework_instance_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 framework_id_;
  ::google::protobuf::uint32 framework_instance_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_FwmRcProtocol_2eproto();
  friend void protobuf_AssignDesc_FwmRcProtocol_2eproto();
  friend void protobuf_ShutdownFile_FwmRcProtocol_2eproto();
  
  void InitAsDefaultInstance();
  static FrameworkInstanceInfo* default_instance_;
};
// -------------------------------------------------------------------

class NetAddress : public ::google::protobuf::Message {
 public:
  NetAddress();
  virtual ~NetAddress();
  
  NetAddress(const NetAddress& from);
  
  inline NetAddress& operator=(const NetAddress& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NetAddress& default_instance();
  
  void Swap(NetAddress* other);
  
  // implements Message ----------------------------------------------
  
  NetAddress* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NetAddress& from);
  void MergeFrom(const NetAddress& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  
  // optional uint32 port = 2;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:FwmRcProto.NetAddress)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* ip_;
  ::google::protobuf::uint32 port_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_FwmRcProtocol_2eproto();
  friend void protobuf_AssignDesc_FwmRcProtocol_2eproto();
  friend void protobuf_ShutdownFile_FwmRcProtocol_2eproto();
  
  void InitAsDefaultInstance();
  static NetAddress* default_instance_;
};
// -------------------------------------------------------------------

class AddressResourceInfo : public ::google::protobuf::Message {
 public:
  AddressResourceInfo();
  virtual ~AddressResourceInfo();
  
  AddressResourceInfo(const AddressResourceInfo& from);
  
  inline AddressResourceInfo& operator=(const AddressResourceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddressResourceInfo& default_instance();
  
  void Swap(AddressResourceInfo* other);
  
  // implements Message ----------------------------------------------
  
  AddressResourceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddressResourceInfo& from);
  void MergeFrom(const AddressResourceInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .FwmRcProto.FrameworkInstanceInfo framework_instance_info = 1;
  inline bool has_framework_instance_info() const;
  inline void clear_framework_instance_info();
  static const int kFrameworkInstanceInfoFieldNumber = 1;
  inline const ::FwmRcProto::FrameworkInstanceInfo& framework_instance_info() const;
  inline ::FwmRcProto::FrameworkInstanceInfo* mutable_framework_instance_info();
  inline ::FwmRcProto::FrameworkInstanceInfo* release_framework_instance_info();
  
  // optional string ip = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 2;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  
  // optional .FwmRcProto.ResourceInfo resource_info = 3;
  inline bool has_resource_info() const;
  inline void clear_resource_info();
  static const int kResourceInfoFieldNumber = 3;
  inline const ::FwmRcProto::ResourceInfo& resource_info() const;
  inline ::FwmRcProto::ResourceInfo* mutable_resource_info();
  inline ::FwmRcProto::ResourceInfo* release_resource_info();
  
  // @@protoc_insertion_point(class_scope:FwmRcProto.AddressResourceInfo)
 private:
  inline void set_has_framework_instance_info();
  inline void clear_has_framework_instance_info();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_resource_info();
  inline void clear_has_resource_info();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::FwmRcProto::FrameworkInstanceInfo* framework_instance_info_;
  ::std::string* ip_;
  ::FwmRcProto::ResourceInfo* resource_info_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_FwmRcProtocol_2eproto();
  friend void protobuf_AssignDesc_FwmRcProtocol_2eproto();
  friend void protobuf_ShutdownFile_FwmRcProtocol_2eproto();
  
  void InitAsDefaultInstance();
  static AddressResourceInfo* default_instance_;
};
// -------------------------------------------------------------------

class FWMasterInfo : public ::google::protobuf::Message {
 public:
  FWMasterInfo();
  virtual ~FWMasterInfo();
  
  FWMasterInfo(const FWMasterInfo& from);
  
  inline FWMasterInfo& operator=(const FWMasterInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FWMasterInfo& default_instance();
  
  void Swap(FWMasterInfo* other);
  
  // implements Message ----------------------------------------------
  
  FWMasterInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FWMasterInfo& from);
  void MergeFrom(const FWMasterInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string module_name = 1;
  inline bool has_module_name() const;
  inline void clear_module_name();
  static const int kModuleNameFieldNumber = 1;
  inline const ::std::string& module_name() const;
  inline void set_module_name(const ::std::string& value);
  inline void set_module_name(const char* value);
  inline void set_module_name(const char* value, size_t size);
  inline ::std::string* mutable_module_name();
  inline ::std::string* release_module_name();
  
  // optional string FW_master_ip = 2;
  inline bool has_fw_master_ip() const;
  inline void clear_fw_master_ip();
  static const int kFWMasterIpFieldNumber = 2;
  inline const ::std::string& fw_master_ip() const;
  inline void set_fw_master_ip(const ::std::string& value);
  inline void set_fw_master_ip(const char* value);
  inline void set_fw_master_ip(const char* value, size_t size);
  inline ::std::string* mutable_fw_master_ip();
  inline ::std::string* release_fw_master_ip();
  
  // @@protoc_insertion_point(class_scope:FwmRcProto.FWMasterInfo)
 private:
  inline void set_has_module_name();
  inline void clear_has_module_name();
  inline void set_has_fw_master_ip();
  inline void clear_has_fw_master_ip();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* module_name_;
  ::std::string* fw_master_ip_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_FwmRcProtocol_2eproto();
  friend void protobuf_AssignDesc_FwmRcProtocol_2eproto();
  friend void protobuf_ShutdownFile_FwmRcProtocol_2eproto();
  
  void InitAsDefaultInstance();
  static FWMasterInfo* default_instance_;
};
// -------------------------------------------------------------------

class FWMRCRegister : public ::google::protobuf::Message {
 public:
  FWMRCRegister();
  virtual ~FWMRCRegister();
  
  FWMRCRegister(const FWMRCRegister& from);
  
  inline FWMRCRegister& operator=(const FWMRCRegister& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FWMRCRegister& default_instance();
  
  void Swap(FWMRCRegister* other);
  
  // implements Message ----------------------------------------------
  
  FWMRCRegister* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FWMRCRegister& from);
  void MergeFrom(const FWMRCRegister& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .FwmRcProto.FrameworkInstanceInfo framework_instance_info = 1;
  inline bool has_framework_instance_info() const;
  inline void clear_framework_instance_info();
  static const int kFrameworkInstanceInfoFieldNumber = 1;
  inline const ::FwmRcProto::FrameworkInstanceInfo& framework_instance_info() const;
  inline ::FwmRcProto::FrameworkInstanceInfo* mutable_framework_instance_info();
  inline ::FwmRcProto::FrameworkInstanceInfo* release_framework_instance_info();
  
  // optional .FwmRcProto.FWMasterInfo framework_master_info = 2;
  inline bool has_framework_master_info() const;
  inline void clear_framework_master_info();
  static const int kFrameworkMasterInfoFieldNumber = 2;
  inline const ::FwmRcProto::FWMasterInfo& framework_master_info() const;
  inline ::FwmRcProto::FWMasterInfo* mutable_framework_master_info();
  inline ::FwmRcProto::FWMasterInfo* release_framework_master_info();
  
  // optional .FwmRcProto.NetAddress data_search_entry = 3;
  inline bool has_data_search_entry() const;
  inline void clear_data_search_entry();
  static const int kDataSearchEntryFieldNumber = 3;
  inline const ::FwmRcProto::NetAddress& data_search_entry() const;
  inline ::FwmRcProto::NetAddress* mutable_data_search_entry();
  inline ::FwmRcProto::NetAddress* release_data_search_entry();
  
  // @@protoc_insertion_point(class_scope:FwmRcProto.FWMRCRegister)
 private:
  inline void set_has_framework_instance_info();
  inline void clear_has_framework_instance_info();
  inline void set_has_framework_master_info();
  inline void clear_has_framework_master_info();
  inline void set_has_data_search_entry();
  inline void clear_has_data_search_entry();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::FwmRcProto::FrameworkInstanceInfo* framework_instance_info_;
  ::FwmRcProto::FWMasterInfo* framework_master_info_;
  ::FwmRcProto::NetAddress* data_search_entry_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_FwmRcProtocol_2eproto();
  friend void protobuf_AssignDesc_FwmRcProtocol_2eproto();
  friend void protobuf_ShutdownFile_FwmRcProtocol_2eproto();
  
  void InitAsDefaultInstance();
  static FWMRCRegister* default_instance_;
};
// -------------------------------------------------------------------

class FWMRCRegisterACK : public ::google::protobuf::Message {
 public:
  FWMRCRegisterACK();
  virtual ~FWMRCRegisterACK();
  
  FWMRCRegisterACK(const FWMRCRegisterACK& from);
  
  inline FWMRCRegisterACK& operator=(const FWMRCRegisterACK& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FWMRCRegisterACK& default_instance();
  
  void Swap(FWMRCRegisterACK* other);
  
  // implements Message ----------------------------------------------
  
  FWMRCRegisterACK* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FWMRCRegisterACK& from);
  void MergeFrom(const FWMRCRegisterACK& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 statuscode = 1;
  inline bool has_statuscode() const;
  inline void clear_statuscode();
  static const int kStatuscodeFieldNumber = 1;
  inline ::google::protobuf::int32 statuscode() const;
  inline void set_statuscode(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:FwmRcProto.FWMRCRegisterACK)
 private:
  inline void set_has_statuscode();
  inline void clear_has_statuscode();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 statuscode_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_FwmRcProtocol_2eproto();
  friend void protobuf_AssignDesc_FwmRcProtocol_2eproto();
  friend void protobuf_ShutdownFile_FwmRcProtocol_2eproto();
  
  void InitAsDefaultInstance();
  static FWMRCRegisterACK* default_instance_;
};
// -------------------------------------------------------------------

class EachMachineResourceInfo : public ::google::protobuf::Message {
 public:
  EachMachineResourceInfo();
  virtual ~EachMachineResourceInfo();
  
  EachMachineResourceInfo(const EachMachineResourceInfo& from);
  
  inline EachMachineResourceInfo& operator=(const EachMachineResourceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const EachMachineResourceInfo& default_instance();
  
  void Swap(EachMachineResourceInfo* other);
  
  // implements Message ----------------------------------------------
  
  EachMachineResourceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EachMachineResourceInfo& from);
  void MergeFrom(const EachMachineResourceInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  
  // optional .FwmRcProto.ResourceInfo resource_info = 2;
  inline bool has_resource_info() const;
  inline void clear_resource_info();
  static const int kResourceInfoFieldNumber = 2;
  inline const ::FwmRcProto::ResourceInfo& resource_info() const;
  inline ::FwmRcProto::ResourceInfo* mutable_resource_info();
  inline ::FwmRcProto::ResourceInfo* release_resource_info();
  
  // @@protoc_insertion_point(class_scope:FwmRcProto.EachMachineResourceInfo)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_resource_info();
  inline void clear_has_resource_info();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* ip_;
  ::FwmRcProto::ResourceInfo* resource_info_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_FwmRcProtocol_2eproto();
  friend void protobuf_AssignDesc_FwmRcProtocol_2eproto();
  friend void protobuf_ShutdownFile_FwmRcProtocol_2eproto();
  
  void InitAsDefaultInstance();
  static EachMachineResourceInfo* default_instance_;
};
// -------------------------------------------------------------------

class RequestSlaveResource : public ::google::protobuf::Message {
 public:
  RequestSlaveResource();
  virtual ~RequestSlaveResource();
  
  RequestSlaveResource(const RequestSlaveResource& from);
  
  inline RequestSlaveResource& operator=(const RequestSlaveResource& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestSlaveResource& default_instance();
  
  void Swap(RequestSlaveResource* other);
  
  // implements Message ----------------------------------------------
  
  RequestSlaveResource* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestSlaveResource& from);
  void MergeFrom(const RequestSlaveResource& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .FwmRcProto.FrameworkInstanceInfo framework_instance_info = 1;
  inline bool has_framework_instance_info() const;
  inline void clear_framework_instance_info();
  static const int kFrameworkInstanceInfoFieldNumber = 1;
  inline const ::FwmRcProto::FrameworkInstanceInfo& framework_instance_info() const;
  inline ::FwmRcProto::FrameworkInstanceInfo* mutable_framework_instance_info();
  inline ::FwmRcProto::FrameworkInstanceInfo* release_framework_instance_info();
  
  // optional string module_name = 2;
  inline bool has_module_name() const;
  inline void clear_module_name();
  static const int kModuleNameFieldNumber = 2;
  inline const ::std::string& module_name() const;
  inline void set_module_name(const ::std::string& value);
  inline void set_module_name(const char* value);
  inline void set_module_name(const char* value, size_t size);
  inline ::std::string* mutable_module_name();
  inline ::std::string* release_module_name();
  
  // repeated .FwmRcProto.EachMachineResourceInfo each_resource_info = 3;
  inline int each_resource_info_size() const;
  inline void clear_each_resource_info();
  static const int kEachResourceInfoFieldNumber = 3;
  inline const ::FwmRcProto::EachMachineResourceInfo& each_resource_info(int index) const;
  inline ::FwmRcProto::EachMachineResourceInfo* mutable_each_resource_info(int index);
  inline ::FwmRcProto::EachMachineResourceInfo* add_each_resource_info();
  inline const ::google::protobuf::RepeatedPtrField< ::FwmRcProto::EachMachineResourceInfo >&
      each_resource_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::FwmRcProto::EachMachineResourceInfo >*
      mutable_each_resource_info();
  
  // @@protoc_insertion_point(class_scope:FwmRcProto.RequestSlaveResource)
 private:
  inline void set_has_framework_instance_info();
  inline void clear_has_framework_instance_info();
  inline void set_has_module_name();
  inline void clear_has_module_name();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::FwmRcProto::FrameworkInstanceInfo* framework_instance_info_;
  ::std::string* module_name_;
  ::google::protobuf::RepeatedPtrField< ::FwmRcProto::EachMachineResourceInfo > each_resource_info_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_FwmRcProtocol_2eproto();
  friend void protobuf_AssignDesc_FwmRcProtocol_2eproto();
  friend void protobuf_ShutdownFile_FwmRcProtocol_2eproto();
  
  void InitAsDefaultInstance();
  static RequestSlaveResource* default_instance_;
};
// -------------------------------------------------------------------

class EachNCResourceAddress : public ::google::protobuf::Message {
 public:
  EachNCResourceAddress();
  virtual ~EachNCResourceAddress();
  
  EachNCResourceAddress(const EachNCResourceAddress& from);
  
  inline EachNCResourceAddress& operator=(const EachNCResourceAddress& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const EachNCResourceAddress& default_instance();
  
  void Swap(EachNCResourceAddress* other);
  
  // implements Message ----------------------------------------------
  
  EachNCResourceAddress* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EachNCResourceAddress& from);
  void MergeFrom(const EachNCResourceAddress& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .FwmRcProto.NetAddress NC_net_address = 1;
  inline bool has_nc_net_address() const;
  inline void clear_nc_net_address();
  static const int kNCNetAddressFieldNumber = 1;
  inline const ::FwmRcProto::NetAddress& nc_net_address() const;
  inline ::FwmRcProto::NetAddress* mutable_nc_net_address();
  inline ::FwmRcProto::NetAddress* release_nc_net_address();
  
  // optional .FwmRcProto.ResourceInfo resource_info = 2;
  inline bool has_resource_info() const;
  inline void clear_resource_info();
  static const int kResourceInfoFieldNumber = 2;
  inline const ::FwmRcProto::ResourceInfo& resource_info() const;
  inline ::FwmRcProto::ResourceInfo* mutable_resource_info();
  inline ::FwmRcProto::ResourceInfo* release_resource_info();
  
  // @@protoc_insertion_point(class_scope:FwmRcProto.EachNCResourceAddress)
 private:
  inline void set_has_nc_net_address();
  inline void clear_has_nc_net_address();
  inline void set_has_resource_info();
  inline void clear_has_resource_info();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::FwmRcProto::NetAddress* nc_net_address_;
  ::FwmRcProto::ResourceInfo* resource_info_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_FwmRcProtocol_2eproto();
  friend void protobuf_AssignDesc_FwmRcProtocol_2eproto();
  friend void protobuf_ShutdownFile_FwmRcProtocol_2eproto();
  
  void InitAsDefaultInstance();
  static EachNCResourceAddress* default_instance_;
};
// -------------------------------------------------------------------

class RespondRequestSlaveResource : public ::google::protobuf::Message {
 public:
  RespondRequestSlaveResource();
  virtual ~RespondRequestSlaveResource();
  
  RespondRequestSlaveResource(const RespondRequestSlaveResource& from);
  
  inline RespondRequestSlaveResource& operator=(const RespondRequestSlaveResource& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RespondRequestSlaveResource& default_instance();
  
  void Swap(RespondRequestSlaveResource* other);
  
  // implements Message ----------------------------------------------
  
  RespondRequestSlaveResource* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RespondRequestSlaveResource& from);
  void MergeFrom(const RespondRequestSlaveResource& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .FwmRcProto.EachNCResourceAddress address_resource_info = 1;
  inline int address_resource_info_size() const;
  inline void clear_address_resource_info();
  static const int kAddressResourceInfoFieldNumber = 1;
  inline const ::FwmRcProto::EachNCResourceAddress& address_resource_info(int index) const;
  inline ::FwmRcProto::EachNCResourceAddress* mutable_address_resource_info(int index);
  inline ::FwmRcProto::EachNCResourceAddress* add_address_resource_info();
  inline const ::google::protobuf::RepeatedPtrField< ::FwmRcProto::EachNCResourceAddress >&
      address_resource_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::FwmRcProto::EachNCResourceAddress >*
      mutable_address_resource_info();
  
  // @@protoc_insertion_point(class_scope:FwmRcProto.RespondRequestSlaveResource)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::FwmRcProto::EachNCResourceAddress > address_resource_info_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_FwmRcProtocol_2eproto();
  friend void protobuf_AssignDesc_FwmRcProtocol_2eproto();
  friend void protobuf_ShutdownFile_FwmRcProtocol_2eproto();
  
  void InitAsDefaultInstance();
  static RespondRequestSlaveResource* default_instance_;
};
// -------------------------------------------------------------------

class EachSlaveInfo : public ::google::protobuf::Message {
 public:
  EachSlaveInfo();
  virtual ~EachSlaveInfo();
  
  EachSlaveInfo(const EachSlaveInfo& from);
  
  inline EachSlaveInfo& operator=(const EachSlaveInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const EachSlaveInfo& default_instance();
  
  void Swap(EachSlaveInfo* other);
  
  // implements Message ----------------------------------------------
  
  EachSlaveInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EachSlaveInfo& from);
  void MergeFrom(const EachSlaveInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .FwmRcProto.FrameworkInstanceInfo framework_instance_info = 1;
  inline bool has_framework_instance_info() const;
  inline void clear_framework_instance_info();
  static const int kFrameworkInstanceInfoFieldNumber = 1;
  inline const ::FwmRcProto::FrameworkInstanceInfo& framework_instance_info() const;
  inline ::FwmRcProto::FrameworkInstanceInfo* mutable_framework_instance_info();
  inline ::FwmRcProto::FrameworkInstanceInfo* release_framework_instance_info();
  
  // optional string framework_slave_ip = 2;
  inline bool has_framework_slave_ip() const;
  inline void clear_framework_slave_ip();
  static const int kFrameworkSlaveIpFieldNumber = 2;
  inline const ::std::string& framework_slave_ip() const;
  inline void set_framework_slave_ip(const ::std::string& value);
  inline void set_framework_slave_ip(const char* value);
  inline void set_framework_slave_ip(const char* value, size_t size);
  inline ::std::string* mutable_framework_slave_ip();
  inline ::std::string* release_framework_slave_ip();
  
  // optional uint32 framework_slave_PID = 3;
  inline bool has_framework_slave_pid() const;
  inline void clear_framework_slave_pid();
  static const int kFrameworkSlavePIDFieldNumber = 3;
  inline ::google::protobuf::uint32 framework_slave_pid() const;
  inline void set_framework_slave_pid(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:FwmRcProto.EachSlaveInfo)
 private:
  inline void set_has_framework_instance_info();
  inline void clear_has_framework_instance_info();
  inline void set_has_framework_slave_ip();
  inline void clear_has_framework_slave_ip();
  inline void set_has_framework_slave_pid();
  inline void clear_has_framework_slave_pid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::FwmRcProto::FrameworkInstanceInfo* framework_instance_info_;
  ::std::string* framework_slave_ip_;
  ::google::protobuf::uint32 framework_slave_pid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_FwmRcProtocol_2eproto();
  friend void protobuf_AssignDesc_FwmRcProtocol_2eproto();
  friend void protobuf_ShutdownFile_FwmRcProtocol_2eproto();
  
  void InitAsDefaultInstance();
  static EachSlaveInfo* default_instance_;
};
// -------------------------------------------------------------------

class SuccessSlaveInfo : public ::google::protobuf::Message {
 public:
  SuccessSlaveInfo();
  virtual ~SuccessSlaveInfo();
  
  SuccessSlaveInfo(const SuccessSlaveInfo& from);
  
  inline SuccessSlaveInfo& operator=(const SuccessSlaveInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SuccessSlaveInfo& default_instance();
  
  void Swap(SuccessSlaveInfo* other);
  
  // implements Message ----------------------------------------------
  
  SuccessSlaveInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SuccessSlaveInfo& from);
  void MergeFrom(const SuccessSlaveInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .FwmRcProto.EachSlaveInfo success_slave_info = 1;
  inline int success_slave_info_size() const;
  inline void clear_success_slave_info();
  static const int kSuccessSlaveInfoFieldNumber = 1;
  inline const ::FwmRcProto::EachSlaveInfo& success_slave_info(int index) const;
  inline ::FwmRcProto::EachSlaveInfo* mutable_success_slave_info(int index);
  inline ::FwmRcProto::EachSlaveInfo* add_success_slave_info();
  inline const ::google::protobuf::RepeatedPtrField< ::FwmRcProto::EachSlaveInfo >&
      success_slave_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::FwmRcProto::EachSlaveInfo >*
      mutable_success_slave_info();
  
  // @@protoc_insertion_point(class_scope:FwmRcProto.SuccessSlaveInfo)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::FwmRcProto::EachSlaveInfo > success_slave_info_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_FwmRcProtocol_2eproto();
  friend void protobuf_AssignDesc_FwmRcProtocol_2eproto();
  friend void protobuf_ShutdownFile_FwmRcProtocol_2eproto();
  
  void InitAsDefaultInstance();
  static SuccessSlaveInfo* default_instance_;
};
// -------------------------------------------------------------------

class RequestTaskResource : public ::google::protobuf::Message {
 public:
  RequestTaskResource();
  virtual ~RequestTaskResource();
  
  RequestTaskResource(const RequestTaskResource& from);
  
  inline RequestTaskResource& operator=(const RequestTaskResource& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestTaskResource& default_instance();
  
  void Swap(RequestTaskResource* other);
  
  // implements Message ----------------------------------------------
  
  RequestTaskResource* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestTaskResource& from);
  void MergeFrom(const RequestTaskResource& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .FwmRcProto.AddressResourceInfo task_resource_info = 1;
  inline int task_resource_info_size() const;
  inline void clear_task_resource_info();
  static const int kTaskResourceInfoFieldNumber = 1;
  inline const ::FwmRcProto::AddressResourceInfo& task_resource_info(int index) const;
  inline ::FwmRcProto::AddressResourceInfo* mutable_task_resource_info(int index);
  inline ::FwmRcProto::AddressResourceInfo* add_task_resource_info();
  inline const ::google::protobuf::RepeatedPtrField< ::FwmRcProto::AddressResourceInfo >&
      task_resource_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::FwmRcProto::AddressResourceInfo >*
      mutable_task_resource_info();
  
  // @@protoc_insertion_point(class_scope:FwmRcProto.RequestTaskResource)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::FwmRcProto::AddressResourceInfo > task_resource_info_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_FwmRcProtocol_2eproto();
  friend void protobuf_AssignDesc_FwmRcProtocol_2eproto();
  friend void protobuf_ShutdownFile_FwmRcProtocol_2eproto();
  
  void InitAsDefaultInstance();
  static RequestTaskResource* default_instance_;
};
// -------------------------------------------------------------------

class ResourceAddress : public ::google::protobuf::Message {
 public:
  ResourceAddress();
  virtual ~ResourceAddress();
  
  ResourceAddress(const ResourceAddress& from);
  
  inline ResourceAddress& operator=(const ResourceAddress& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResourceAddress& default_instance();
  
  void Swap(ResourceAddress* other);
  
  // implements Message ----------------------------------------------
  
  ResourceAddress* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResourceAddress& from);
  void MergeFrom(const ResourceAddress& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .FwmRcProto.NetAddress NC_net_address = 1;
  inline bool has_nc_net_address() const;
  inline void clear_nc_net_address();
  static const int kNCNetAddressFieldNumber = 1;
  inline const ::FwmRcProto::NetAddress& nc_net_address() const;
  inline ::FwmRcProto::NetAddress* mutable_nc_net_address();
  inline ::FwmRcProto::NetAddress* release_nc_net_address();
  
  // optional .FwmRcProto.FrameworkInstanceInfo framework_instance_info = 2;
  inline bool has_framework_instance_info() const;
  inline void clear_framework_instance_info();
  static const int kFrameworkInstanceInfoFieldNumber = 2;
  inline const ::FwmRcProto::FrameworkInstanceInfo& framework_instance_info() const;
  inline ::FwmRcProto::FrameworkInstanceInfo* mutable_framework_instance_info();
  inline ::FwmRcProto::FrameworkInstanceInfo* release_framework_instance_info();
  
  // @@protoc_insertion_point(class_scope:FwmRcProto.ResourceAddress)
 private:
  inline void set_has_nc_net_address();
  inline void clear_has_nc_net_address();
  inline void set_has_framework_instance_info();
  inline void clear_has_framework_instance_info();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::FwmRcProto::NetAddress* nc_net_address_;
  ::FwmRcProto::FrameworkInstanceInfo* framework_instance_info_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_FwmRcProtocol_2eproto();
  friend void protobuf_AssignDesc_FwmRcProtocol_2eproto();
  friend void protobuf_ShutdownFile_FwmRcProtocol_2eproto();
  
  void InitAsDefaultInstance();
  static ResourceAddress* default_instance_;
};
// -------------------------------------------------------------------

class RespondRequestTaskResource : public ::google::protobuf::Message {
 public:
  RespondRequestTaskResource();
  virtual ~RespondRequestTaskResource();
  
  RespondRequestTaskResource(const RespondRequestTaskResource& from);
  
  inline RespondRequestTaskResource& operator=(const RespondRequestTaskResource& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RespondRequestTaskResource& default_instance();
  
  void Swap(RespondRequestTaskResource* other);
  
  // implements Message ----------------------------------------------
  
  RespondRequestTaskResource* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RespondRequestTaskResource& from);
  void MergeFrom(const RespondRequestTaskResource& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .FwmRcProto.ResourceAddress resource_address = 1;
  inline int resource_address_size() const;
  inline void clear_resource_address();
  static const int kResourceAddressFieldNumber = 1;
  inline const ::FwmRcProto::ResourceAddress& resource_address(int index) const;
  inline ::FwmRcProto::ResourceAddress* mutable_resource_address(int index);
  inline ::FwmRcProto::ResourceAddress* add_resource_address();
  inline const ::google::protobuf::RepeatedPtrField< ::FwmRcProto::ResourceAddress >&
      resource_address() const;
  inline ::google::protobuf::RepeatedPtrField< ::FwmRcProto::ResourceAddress >*
      mutable_resource_address();
  
  // @@protoc_insertion_point(class_scope:FwmRcProto.RespondRequestTaskResource)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::FwmRcProto::ResourceAddress > resource_address_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_FwmRcProtocol_2eproto();
  friend void protobuf_AssignDesc_FwmRcProtocol_2eproto();
  friend void protobuf_ShutdownFile_FwmRcProtocol_2eproto();
  
  void InitAsDefaultInstance();
  static RespondRequestTaskResource* default_instance_;
};
// -------------------------------------------------------------------

class ReturnTaskResource : public ::google::protobuf::Message {
 public:
  ReturnTaskResource();
  virtual ~ReturnTaskResource();
  
  ReturnTaskResource(const ReturnTaskResource& from);
  
  inline ReturnTaskResource& operator=(const ReturnTaskResource& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReturnTaskResource& default_instance();
  
  void Swap(ReturnTaskResource* other);
  
  // implements Message ----------------------------------------------
  
  ReturnTaskResource* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReturnTaskResource& from);
  void MergeFrom(const ReturnTaskResource& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .FwmRcProto.AddressResourceInfo task_resource_info = 1;
  inline int task_resource_info_size() const;
  inline void clear_task_resource_info();
  static const int kTaskResourceInfoFieldNumber = 1;
  inline const ::FwmRcProto::AddressResourceInfo& task_resource_info(int index) const;
  inline ::FwmRcProto::AddressResourceInfo* mutable_task_resource_info(int index);
  inline ::FwmRcProto::AddressResourceInfo* add_task_resource_info();
  inline const ::google::protobuf::RepeatedPtrField< ::FwmRcProto::AddressResourceInfo >&
      task_resource_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::FwmRcProto::AddressResourceInfo >*
      mutable_task_resource_info();
  
  // @@protoc_insertion_point(class_scope:FwmRcProto.ReturnTaskResource)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::FwmRcProto::AddressResourceInfo > task_resource_info_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_FwmRcProtocol_2eproto();
  friend void protobuf_AssignDesc_FwmRcProtocol_2eproto();
  friend void protobuf_ShutdownFile_FwmRcProtocol_2eproto();
  
  void InitAsDefaultInstance();
  static ReturnTaskResource* default_instance_;
};
// -------------------------------------------------------------------

class IPProcessInfo : public ::google::protobuf::Message {
 public:
  IPProcessInfo();
  virtual ~IPProcessInfo();
  
  IPProcessInfo(const IPProcessInfo& from);
  
  inline IPProcessInfo& operator=(const IPProcessInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const IPProcessInfo& default_instance();
  
  void Swap(IPProcessInfo* other);
  
  // implements Message ----------------------------------------------
  
  IPProcessInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IPProcessInfo& from);
  void MergeFrom(const IPProcessInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  
  // optional uint32 process_id = 2;
  inline bool has_process_id() const;
  inline void clear_process_id();
  static const int kProcessIdFieldNumber = 2;
  inline ::google::protobuf::uint32 process_id() const;
  inline void set_process_id(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:FwmRcProto.IPProcessInfo)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_process_id();
  inline void clear_has_process_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* ip_;
  ::google::protobuf::uint32 process_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_FwmRcProtocol_2eproto();
  friend void protobuf_AssignDesc_FwmRcProtocol_2eproto();
  friend void protobuf_ShutdownFile_FwmRcProtocol_2eproto();
  
  void InitAsDefaultInstance();
  static IPProcessInfo* default_instance_;
};
// -------------------------------------------------------------------

class StopModuleInfo : public ::google::protobuf::Message {
 public:
  StopModuleInfo();
  virtual ~StopModuleInfo();
  
  StopModuleInfo(const StopModuleInfo& from);
  
  inline StopModuleInfo& operator=(const StopModuleInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StopModuleInfo& default_instance();
  
  void Swap(StopModuleInfo* other);
  
  // implements Message ----------------------------------------------
  
  StopModuleInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StopModuleInfo& from);
  void MergeFrom(const StopModuleInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .FwmRcProto.FrameworkInstanceInfo framework_Instance = 1;
  inline bool has_framework_instance() const;
  inline void clear_framework_instance();
  static const int kFrameworkInstanceFieldNumber = 1;
  inline const ::FwmRcProto::FrameworkInstanceInfo& framework_instance() const;
  inline ::FwmRcProto::FrameworkInstanceInfo* mutable_framework_instance();
  inline ::FwmRcProto::FrameworkInstanceInfo* release_framework_instance();
  
  // repeated .FwmRcProto.IPProcessInfo ip_process = 2;
  inline int ip_process_size() const;
  inline void clear_ip_process();
  static const int kIpProcessFieldNumber = 2;
  inline const ::FwmRcProto::IPProcessInfo& ip_process(int index) const;
  inline ::FwmRcProto::IPProcessInfo* mutable_ip_process(int index);
  inline ::FwmRcProto::IPProcessInfo* add_ip_process();
  inline const ::google::protobuf::RepeatedPtrField< ::FwmRcProto::IPProcessInfo >&
      ip_process() const;
  inline ::google::protobuf::RepeatedPtrField< ::FwmRcProto::IPProcessInfo >*
      mutable_ip_process();
  
  // @@protoc_insertion_point(class_scope:FwmRcProto.StopModuleInfo)
 private:
  inline void set_has_framework_instance();
  inline void clear_has_framework_instance();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::FwmRcProto::FrameworkInstanceInfo* framework_instance_;
  ::google::protobuf::RepeatedPtrField< ::FwmRcProto::IPProcessInfo > ip_process_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_FwmRcProtocol_2eproto();
  friend void protobuf_AssignDesc_FwmRcProtocol_2eproto();
  friend void protobuf_ShutdownFile_FwmRcProtocol_2eproto();
  
  void InitAsDefaultInstance();
  static StopModuleInfo* default_instance_;
};
// ===================================================================


// ===================================================================

// GpuResourceInfo

// required string gpu_name = 1;
inline bool GpuResourceInfo::has_gpu_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GpuResourceInfo::set_has_gpu_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GpuResourceInfo::clear_has_gpu_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GpuResourceInfo::clear_gpu_name() {
  if (gpu_name_ != &::google::protobuf::internal::kEmptyString) {
    gpu_name_->clear();
  }
  clear_has_gpu_name();
}
inline const ::std::string& GpuResourceInfo::gpu_name() const {
  return *gpu_name_;
}
inline void GpuResourceInfo::set_gpu_name(const ::std::string& value) {
  set_has_gpu_name();
  if (gpu_name_ == &::google::protobuf::internal::kEmptyString) {
    gpu_name_ = new ::std::string;
  }
  gpu_name_->assign(value);
}
inline void GpuResourceInfo::set_gpu_name(const char* value) {
  set_has_gpu_name();
  if (gpu_name_ == &::google::protobuf::internal::kEmptyString) {
    gpu_name_ = new ::std::string;
  }
  gpu_name_->assign(value);
}
inline void GpuResourceInfo::set_gpu_name(const char* value, size_t size) {
  set_has_gpu_name();
  if (gpu_name_ == &::google::protobuf::internal::kEmptyString) {
    gpu_name_ = new ::std::string;
  }
  gpu_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GpuResourceInfo::mutable_gpu_name() {
  set_has_gpu_name();
  if (gpu_name_ == &::google::protobuf::internal::kEmptyString) {
    gpu_name_ = new ::std::string;
  }
  return gpu_name_;
}
inline ::std::string* GpuResourceInfo::release_gpu_name() {
  clear_has_gpu_name();
  if (gpu_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gpu_name_;
    gpu_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 gpu_mem_size = 2;
inline bool GpuResourceInfo::has_gpu_mem_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GpuResourceInfo::set_has_gpu_mem_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GpuResourceInfo::clear_has_gpu_mem_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GpuResourceInfo::clear_gpu_mem_size() {
  gpu_mem_size_ = 0u;
  clear_has_gpu_mem_size();
}
inline ::google::protobuf::uint32 GpuResourceInfo::gpu_mem_size() const {
  return gpu_mem_size_;
}
inline void GpuResourceInfo::set_gpu_mem_size(::google::protobuf::uint32 value) {
  set_has_gpu_mem_size();
  gpu_mem_size_ = value;
}

// -------------------------------------------------------------------

// ResourceInfo

// required double cpu_num = 1;
inline bool ResourceInfo::has_cpu_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResourceInfo::set_has_cpu_num() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResourceInfo::clear_has_cpu_num() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResourceInfo::clear_cpu_num() {
  cpu_num_ = 0;
  clear_has_cpu_num();
}
inline double ResourceInfo::cpu_num() const {
  return cpu_num_;
}
inline void ResourceInfo::set_cpu_num(double value) {
  set_has_cpu_num();
  cpu_num_ = value;
}

// required uint32 cpu_mem_size = 2;
inline bool ResourceInfo::has_cpu_mem_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResourceInfo::set_has_cpu_mem_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResourceInfo::clear_has_cpu_mem_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResourceInfo::clear_cpu_mem_size() {
  cpu_mem_size_ = 0u;
  clear_has_cpu_mem_size();
}
inline ::google::protobuf::uint32 ResourceInfo::cpu_mem_size() const {
  return cpu_mem_size_;
}
inline void ResourceInfo::set_cpu_mem_size(::google::protobuf::uint32 value) {
  set_has_cpu_mem_size();
  cpu_mem_size_ = value;
}

// optional uint32 gpu_num = 3;
inline bool ResourceInfo::has_gpu_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResourceInfo::set_has_gpu_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResourceInfo::clear_has_gpu_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResourceInfo::clear_gpu_num() {
  gpu_num_ = 0u;
  clear_has_gpu_num();
}
inline ::google::protobuf::uint32 ResourceInfo::gpu_num() const {
  return gpu_num_;
}
inline void ResourceInfo::set_gpu_num(::google::protobuf::uint32 value) {
  set_has_gpu_num();
  gpu_num_ = value;
}

// repeated .FwmRcProto.GpuResourceInfo gpu_resource_info = 4;
inline int ResourceInfo::gpu_resource_info_size() const {
  return gpu_resource_info_.size();
}
inline void ResourceInfo::clear_gpu_resource_info() {
  gpu_resource_info_.Clear();
}
inline const ::FwmRcProto::GpuResourceInfo& ResourceInfo::gpu_resource_info(int index) const {
  return gpu_resource_info_.Get(index);
}
inline ::FwmRcProto::GpuResourceInfo* ResourceInfo::mutable_gpu_resource_info(int index) {
  return gpu_resource_info_.Mutable(index);
}
inline ::FwmRcProto::GpuResourceInfo* ResourceInfo::add_gpu_resource_info() {
  return gpu_resource_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FwmRcProto::GpuResourceInfo >&
ResourceInfo::gpu_resource_info() const {
  return gpu_resource_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::FwmRcProto::GpuResourceInfo >*
ResourceInfo::mutable_gpu_resource_info() {
  return &gpu_resource_info_;
}

// -------------------------------------------------------------------

// FrameworkInstanceInfo

// required uint32 framework_id = 1;
inline bool FrameworkInstanceInfo::has_framework_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FrameworkInstanceInfo::set_has_framework_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FrameworkInstanceInfo::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FrameworkInstanceInfo::clear_framework_id() {
  framework_id_ = 0u;
  clear_has_framework_id();
}
inline ::google::protobuf::uint32 FrameworkInstanceInfo::framework_id() const {
  return framework_id_;
}
inline void FrameworkInstanceInfo::set_framework_id(::google::protobuf::uint32 value) {
  set_has_framework_id();
  framework_id_ = value;
}

// required uint32 framework_instance_id = 2;
inline bool FrameworkInstanceInfo::has_framework_instance_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FrameworkInstanceInfo::set_has_framework_instance_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FrameworkInstanceInfo::clear_has_framework_instance_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FrameworkInstanceInfo::clear_framework_instance_id() {
  framework_instance_id_ = 0u;
  clear_has_framework_instance_id();
}
inline ::google::protobuf::uint32 FrameworkInstanceInfo::framework_instance_id() const {
  return framework_instance_id_;
}
inline void FrameworkInstanceInfo::set_framework_instance_id(::google::protobuf::uint32 value) {
  set_has_framework_instance_id();
  framework_instance_id_ = value;
}

// -------------------------------------------------------------------

// NetAddress

// required string ip = 1;
inline bool NetAddress::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NetAddress::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NetAddress::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NetAddress::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& NetAddress::ip() const {
  return *ip_;
}
inline void NetAddress::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void NetAddress::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void NetAddress::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NetAddress::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* NetAddress::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 port = 2;
inline bool NetAddress::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NetAddress::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NetAddress::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NetAddress::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 NetAddress::port() const {
  return port_;
}
inline void NetAddress::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// -------------------------------------------------------------------

// AddressResourceInfo

// required .FwmRcProto.FrameworkInstanceInfo framework_instance_info = 1;
inline bool AddressResourceInfo::has_framework_instance_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddressResourceInfo::set_has_framework_instance_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddressResourceInfo::clear_has_framework_instance_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddressResourceInfo::clear_framework_instance_info() {
  if (framework_instance_info_ != NULL) framework_instance_info_->::FwmRcProto::FrameworkInstanceInfo::Clear();
  clear_has_framework_instance_info();
}
inline const ::FwmRcProto::FrameworkInstanceInfo& AddressResourceInfo::framework_instance_info() const {
  return framework_instance_info_ != NULL ? *framework_instance_info_ : *default_instance_->framework_instance_info_;
}
inline ::FwmRcProto::FrameworkInstanceInfo* AddressResourceInfo::mutable_framework_instance_info() {
  set_has_framework_instance_info();
  if (framework_instance_info_ == NULL) framework_instance_info_ = new ::FwmRcProto::FrameworkInstanceInfo;
  return framework_instance_info_;
}
inline ::FwmRcProto::FrameworkInstanceInfo* AddressResourceInfo::release_framework_instance_info() {
  clear_has_framework_instance_info();
  ::FwmRcProto::FrameworkInstanceInfo* temp = framework_instance_info_;
  framework_instance_info_ = NULL;
  return temp;
}

// optional string ip = 2;
inline bool AddressResourceInfo::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddressResourceInfo::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddressResourceInfo::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AddressResourceInfo::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& AddressResourceInfo::ip() const {
  return *ip_;
}
inline void AddressResourceInfo::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void AddressResourceInfo::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void AddressResourceInfo::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddressResourceInfo::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* AddressResourceInfo::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .FwmRcProto.ResourceInfo resource_info = 3;
inline bool AddressResourceInfo::has_resource_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AddressResourceInfo::set_has_resource_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AddressResourceInfo::clear_has_resource_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AddressResourceInfo::clear_resource_info() {
  if (resource_info_ != NULL) resource_info_->::FwmRcProto::ResourceInfo::Clear();
  clear_has_resource_info();
}
inline const ::FwmRcProto::ResourceInfo& AddressResourceInfo::resource_info() const {
  return resource_info_ != NULL ? *resource_info_ : *default_instance_->resource_info_;
}
inline ::FwmRcProto::ResourceInfo* AddressResourceInfo::mutable_resource_info() {
  set_has_resource_info();
  if (resource_info_ == NULL) resource_info_ = new ::FwmRcProto::ResourceInfo;
  return resource_info_;
}
inline ::FwmRcProto::ResourceInfo* AddressResourceInfo::release_resource_info() {
  clear_has_resource_info();
  ::FwmRcProto::ResourceInfo* temp = resource_info_;
  resource_info_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// FWMasterInfo

// required string module_name = 1;
inline bool FWMasterInfo::has_module_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FWMasterInfo::set_has_module_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FWMasterInfo::clear_has_module_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FWMasterInfo::clear_module_name() {
  if (module_name_ != &::google::protobuf::internal::kEmptyString) {
    module_name_->clear();
  }
  clear_has_module_name();
}
inline const ::std::string& FWMasterInfo::module_name() const {
  return *module_name_;
}
inline void FWMasterInfo::set_module_name(const ::std::string& value) {
  set_has_module_name();
  if (module_name_ == &::google::protobuf::internal::kEmptyString) {
    module_name_ = new ::std::string;
  }
  module_name_->assign(value);
}
inline void FWMasterInfo::set_module_name(const char* value) {
  set_has_module_name();
  if (module_name_ == &::google::protobuf::internal::kEmptyString) {
    module_name_ = new ::std::string;
  }
  module_name_->assign(value);
}
inline void FWMasterInfo::set_module_name(const char* value, size_t size) {
  set_has_module_name();
  if (module_name_ == &::google::protobuf::internal::kEmptyString) {
    module_name_ = new ::std::string;
  }
  module_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FWMasterInfo::mutable_module_name() {
  set_has_module_name();
  if (module_name_ == &::google::protobuf::internal::kEmptyString) {
    module_name_ = new ::std::string;
  }
  return module_name_;
}
inline ::std::string* FWMasterInfo::release_module_name() {
  clear_has_module_name();
  if (module_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = module_name_;
    module_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string FW_master_ip = 2;
inline bool FWMasterInfo::has_fw_master_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FWMasterInfo::set_has_fw_master_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FWMasterInfo::clear_has_fw_master_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FWMasterInfo::clear_fw_master_ip() {
  if (fw_master_ip_ != &::google::protobuf::internal::kEmptyString) {
    fw_master_ip_->clear();
  }
  clear_has_fw_master_ip();
}
inline const ::std::string& FWMasterInfo::fw_master_ip() const {
  return *fw_master_ip_;
}
inline void FWMasterInfo::set_fw_master_ip(const ::std::string& value) {
  set_has_fw_master_ip();
  if (fw_master_ip_ == &::google::protobuf::internal::kEmptyString) {
    fw_master_ip_ = new ::std::string;
  }
  fw_master_ip_->assign(value);
}
inline void FWMasterInfo::set_fw_master_ip(const char* value) {
  set_has_fw_master_ip();
  if (fw_master_ip_ == &::google::protobuf::internal::kEmptyString) {
    fw_master_ip_ = new ::std::string;
  }
  fw_master_ip_->assign(value);
}
inline void FWMasterInfo::set_fw_master_ip(const char* value, size_t size) {
  set_has_fw_master_ip();
  if (fw_master_ip_ == &::google::protobuf::internal::kEmptyString) {
    fw_master_ip_ = new ::std::string;
  }
  fw_master_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FWMasterInfo::mutable_fw_master_ip() {
  set_has_fw_master_ip();
  if (fw_master_ip_ == &::google::protobuf::internal::kEmptyString) {
    fw_master_ip_ = new ::std::string;
  }
  return fw_master_ip_;
}
inline ::std::string* FWMasterInfo::release_fw_master_ip() {
  clear_has_fw_master_ip();
  if (fw_master_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fw_master_ip_;
    fw_master_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// FWMRCRegister

// required .FwmRcProto.FrameworkInstanceInfo framework_instance_info = 1;
inline bool FWMRCRegister::has_framework_instance_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FWMRCRegister::set_has_framework_instance_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FWMRCRegister::clear_has_framework_instance_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FWMRCRegister::clear_framework_instance_info() {
  if (framework_instance_info_ != NULL) framework_instance_info_->::FwmRcProto::FrameworkInstanceInfo::Clear();
  clear_has_framework_instance_info();
}
inline const ::FwmRcProto::FrameworkInstanceInfo& FWMRCRegister::framework_instance_info() const {
  return framework_instance_info_ != NULL ? *framework_instance_info_ : *default_instance_->framework_instance_info_;
}
inline ::FwmRcProto::FrameworkInstanceInfo* FWMRCRegister::mutable_framework_instance_info() {
  set_has_framework_instance_info();
  if (framework_instance_info_ == NULL) framework_instance_info_ = new ::FwmRcProto::FrameworkInstanceInfo;
  return framework_instance_info_;
}
inline ::FwmRcProto::FrameworkInstanceInfo* FWMRCRegister::release_framework_instance_info() {
  clear_has_framework_instance_info();
  ::FwmRcProto::FrameworkInstanceInfo* temp = framework_instance_info_;
  framework_instance_info_ = NULL;
  return temp;
}

// optional .FwmRcProto.FWMasterInfo framework_master_info = 2;
inline bool FWMRCRegister::has_framework_master_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FWMRCRegister::set_has_framework_master_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FWMRCRegister::clear_has_framework_master_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FWMRCRegister::clear_framework_master_info() {
  if (framework_master_info_ != NULL) framework_master_info_->::FwmRcProto::FWMasterInfo::Clear();
  clear_has_framework_master_info();
}
inline const ::FwmRcProto::FWMasterInfo& FWMRCRegister::framework_master_info() const {
  return framework_master_info_ != NULL ? *framework_master_info_ : *default_instance_->framework_master_info_;
}
inline ::FwmRcProto::FWMasterInfo* FWMRCRegister::mutable_framework_master_info() {
  set_has_framework_master_info();
  if (framework_master_info_ == NULL) framework_master_info_ = new ::FwmRcProto::FWMasterInfo;
  return framework_master_info_;
}
inline ::FwmRcProto::FWMasterInfo* FWMRCRegister::release_framework_master_info() {
  clear_has_framework_master_info();
  ::FwmRcProto::FWMasterInfo* temp = framework_master_info_;
  framework_master_info_ = NULL;
  return temp;
}

// optional .FwmRcProto.NetAddress data_search_entry = 3;
inline bool FWMRCRegister::has_data_search_entry() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FWMRCRegister::set_has_data_search_entry() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FWMRCRegister::clear_has_data_search_entry() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FWMRCRegister::clear_data_search_entry() {
  if (data_search_entry_ != NULL) data_search_entry_->::FwmRcProto::NetAddress::Clear();
  clear_has_data_search_entry();
}
inline const ::FwmRcProto::NetAddress& FWMRCRegister::data_search_entry() const {
  return data_search_entry_ != NULL ? *data_search_entry_ : *default_instance_->data_search_entry_;
}
inline ::FwmRcProto::NetAddress* FWMRCRegister::mutable_data_search_entry() {
  set_has_data_search_entry();
  if (data_search_entry_ == NULL) data_search_entry_ = new ::FwmRcProto::NetAddress;
  return data_search_entry_;
}
inline ::FwmRcProto::NetAddress* FWMRCRegister::release_data_search_entry() {
  clear_has_data_search_entry();
  ::FwmRcProto::NetAddress* temp = data_search_entry_;
  data_search_entry_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// FWMRCRegisterACK

// required int32 statuscode = 1;
inline bool FWMRCRegisterACK::has_statuscode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FWMRCRegisterACK::set_has_statuscode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FWMRCRegisterACK::clear_has_statuscode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FWMRCRegisterACK::clear_statuscode() {
  statuscode_ = 0;
  clear_has_statuscode();
}
inline ::google::protobuf::int32 FWMRCRegisterACK::statuscode() const {
  return statuscode_;
}
inline void FWMRCRegisterACK::set_statuscode(::google::protobuf::int32 value) {
  set_has_statuscode();
  statuscode_ = value;
}

// -------------------------------------------------------------------

// EachMachineResourceInfo

// required string ip = 1;
inline bool EachMachineResourceInfo::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EachMachineResourceInfo::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EachMachineResourceInfo::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EachMachineResourceInfo::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& EachMachineResourceInfo::ip() const {
  return *ip_;
}
inline void EachMachineResourceInfo::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void EachMachineResourceInfo::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void EachMachineResourceInfo::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EachMachineResourceInfo::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* EachMachineResourceInfo::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .FwmRcProto.ResourceInfo resource_info = 2;
inline bool EachMachineResourceInfo::has_resource_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EachMachineResourceInfo::set_has_resource_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EachMachineResourceInfo::clear_has_resource_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EachMachineResourceInfo::clear_resource_info() {
  if (resource_info_ != NULL) resource_info_->::FwmRcProto::ResourceInfo::Clear();
  clear_has_resource_info();
}
inline const ::FwmRcProto::ResourceInfo& EachMachineResourceInfo::resource_info() const {
  return resource_info_ != NULL ? *resource_info_ : *default_instance_->resource_info_;
}
inline ::FwmRcProto::ResourceInfo* EachMachineResourceInfo::mutable_resource_info() {
  set_has_resource_info();
  if (resource_info_ == NULL) resource_info_ = new ::FwmRcProto::ResourceInfo;
  return resource_info_;
}
inline ::FwmRcProto::ResourceInfo* EachMachineResourceInfo::release_resource_info() {
  clear_has_resource_info();
  ::FwmRcProto::ResourceInfo* temp = resource_info_;
  resource_info_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// RequestSlaveResource

// required .FwmRcProto.FrameworkInstanceInfo framework_instance_info = 1;
inline bool RequestSlaveResource::has_framework_instance_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestSlaveResource::set_has_framework_instance_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestSlaveResource::clear_has_framework_instance_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestSlaveResource::clear_framework_instance_info() {
  if (framework_instance_info_ != NULL) framework_instance_info_->::FwmRcProto::FrameworkInstanceInfo::Clear();
  clear_has_framework_instance_info();
}
inline const ::FwmRcProto::FrameworkInstanceInfo& RequestSlaveResource::framework_instance_info() const {
  return framework_instance_info_ != NULL ? *framework_instance_info_ : *default_instance_->framework_instance_info_;
}
inline ::FwmRcProto::FrameworkInstanceInfo* RequestSlaveResource::mutable_framework_instance_info() {
  set_has_framework_instance_info();
  if (framework_instance_info_ == NULL) framework_instance_info_ = new ::FwmRcProto::FrameworkInstanceInfo;
  return framework_instance_info_;
}
inline ::FwmRcProto::FrameworkInstanceInfo* RequestSlaveResource::release_framework_instance_info() {
  clear_has_framework_instance_info();
  ::FwmRcProto::FrameworkInstanceInfo* temp = framework_instance_info_;
  framework_instance_info_ = NULL;
  return temp;
}

// optional string module_name = 2;
inline bool RequestSlaveResource::has_module_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestSlaveResource::set_has_module_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestSlaveResource::clear_has_module_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestSlaveResource::clear_module_name() {
  if (module_name_ != &::google::protobuf::internal::kEmptyString) {
    module_name_->clear();
  }
  clear_has_module_name();
}
inline const ::std::string& RequestSlaveResource::module_name() const {
  return *module_name_;
}
inline void RequestSlaveResource::set_module_name(const ::std::string& value) {
  set_has_module_name();
  if (module_name_ == &::google::protobuf::internal::kEmptyString) {
    module_name_ = new ::std::string;
  }
  module_name_->assign(value);
}
inline void RequestSlaveResource::set_module_name(const char* value) {
  set_has_module_name();
  if (module_name_ == &::google::protobuf::internal::kEmptyString) {
    module_name_ = new ::std::string;
  }
  module_name_->assign(value);
}
inline void RequestSlaveResource::set_module_name(const char* value, size_t size) {
  set_has_module_name();
  if (module_name_ == &::google::protobuf::internal::kEmptyString) {
    module_name_ = new ::std::string;
  }
  module_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestSlaveResource::mutable_module_name() {
  set_has_module_name();
  if (module_name_ == &::google::protobuf::internal::kEmptyString) {
    module_name_ = new ::std::string;
  }
  return module_name_;
}
inline ::std::string* RequestSlaveResource::release_module_name() {
  clear_has_module_name();
  if (module_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = module_name_;
    module_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .FwmRcProto.EachMachineResourceInfo each_resource_info = 3;
inline int RequestSlaveResource::each_resource_info_size() const {
  return each_resource_info_.size();
}
inline void RequestSlaveResource::clear_each_resource_info() {
  each_resource_info_.Clear();
}
inline const ::FwmRcProto::EachMachineResourceInfo& RequestSlaveResource::each_resource_info(int index) const {
  return each_resource_info_.Get(index);
}
inline ::FwmRcProto::EachMachineResourceInfo* RequestSlaveResource::mutable_each_resource_info(int index) {
  return each_resource_info_.Mutable(index);
}
inline ::FwmRcProto::EachMachineResourceInfo* RequestSlaveResource::add_each_resource_info() {
  return each_resource_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FwmRcProto::EachMachineResourceInfo >&
RequestSlaveResource::each_resource_info() const {
  return each_resource_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::FwmRcProto::EachMachineResourceInfo >*
RequestSlaveResource::mutable_each_resource_info() {
  return &each_resource_info_;
}

// -------------------------------------------------------------------

// EachNCResourceAddress

// required .FwmRcProto.NetAddress NC_net_address = 1;
inline bool EachNCResourceAddress::has_nc_net_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EachNCResourceAddress::set_has_nc_net_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EachNCResourceAddress::clear_has_nc_net_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EachNCResourceAddress::clear_nc_net_address() {
  if (nc_net_address_ != NULL) nc_net_address_->::FwmRcProto::NetAddress::Clear();
  clear_has_nc_net_address();
}
inline const ::FwmRcProto::NetAddress& EachNCResourceAddress::nc_net_address() const {
  return nc_net_address_ != NULL ? *nc_net_address_ : *default_instance_->nc_net_address_;
}
inline ::FwmRcProto::NetAddress* EachNCResourceAddress::mutable_nc_net_address() {
  set_has_nc_net_address();
  if (nc_net_address_ == NULL) nc_net_address_ = new ::FwmRcProto::NetAddress;
  return nc_net_address_;
}
inline ::FwmRcProto::NetAddress* EachNCResourceAddress::release_nc_net_address() {
  clear_has_nc_net_address();
  ::FwmRcProto::NetAddress* temp = nc_net_address_;
  nc_net_address_ = NULL;
  return temp;
}

// optional .FwmRcProto.ResourceInfo resource_info = 2;
inline bool EachNCResourceAddress::has_resource_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EachNCResourceAddress::set_has_resource_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EachNCResourceAddress::clear_has_resource_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EachNCResourceAddress::clear_resource_info() {
  if (resource_info_ != NULL) resource_info_->::FwmRcProto::ResourceInfo::Clear();
  clear_has_resource_info();
}
inline const ::FwmRcProto::ResourceInfo& EachNCResourceAddress::resource_info() const {
  return resource_info_ != NULL ? *resource_info_ : *default_instance_->resource_info_;
}
inline ::FwmRcProto::ResourceInfo* EachNCResourceAddress::mutable_resource_info() {
  set_has_resource_info();
  if (resource_info_ == NULL) resource_info_ = new ::FwmRcProto::ResourceInfo;
  return resource_info_;
}
inline ::FwmRcProto::ResourceInfo* EachNCResourceAddress::release_resource_info() {
  clear_has_resource_info();
  ::FwmRcProto::ResourceInfo* temp = resource_info_;
  resource_info_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// RespondRequestSlaveResource

// repeated .FwmRcProto.EachNCResourceAddress address_resource_info = 1;
inline int RespondRequestSlaveResource::address_resource_info_size() const {
  return address_resource_info_.size();
}
inline void RespondRequestSlaveResource::clear_address_resource_info() {
  address_resource_info_.Clear();
}
inline const ::FwmRcProto::EachNCResourceAddress& RespondRequestSlaveResource::address_resource_info(int index) const {
  return address_resource_info_.Get(index);
}
inline ::FwmRcProto::EachNCResourceAddress* RespondRequestSlaveResource::mutable_address_resource_info(int index) {
  return address_resource_info_.Mutable(index);
}
inline ::FwmRcProto::EachNCResourceAddress* RespondRequestSlaveResource::add_address_resource_info() {
  return address_resource_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FwmRcProto::EachNCResourceAddress >&
RespondRequestSlaveResource::address_resource_info() const {
  return address_resource_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::FwmRcProto::EachNCResourceAddress >*
RespondRequestSlaveResource::mutable_address_resource_info() {
  return &address_resource_info_;
}

// -------------------------------------------------------------------

// EachSlaveInfo

// required .FwmRcProto.FrameworkInstanceInfo framework_instance_info = 1;
inline bool EachSlaveInfo::has_framework_instance_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EachSlaveInfo::set_has_framework_instance_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EachSlaveInfo::clear_has_framework_instance_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EachSlaveInfo::clear_framework_instance_info() {
  if (framework_instance_info_ != NULL) framework_instance_info_->::FwmRcProto::FrameworkInstanceInfo::Clear();
  clear_has_framework_instance_info();
}
inline const ::FwmRcProto::FrameworkInstanceInfo& EachSlaveInfo::framework_instance_info() const {
  return framework_instance_info_ != NULL ? *framework_instance_info_ : *default_instance_->framework_instance_info_;
}
inline ::FwmRcProto::FrameworkInstanceInfo* EachSlaveInfo::mutable_framework_instance_info() {
  set_has_framework_instance_info();
  if (framework_instance_info_ == NULL) framework_instance_info_ = new ::FwmRcProto::FrameworkInstanceInfo;
  return framework_instance_info_;
}
inline ::FwmRcProto::FrameworkInstanceInfo* EachSlaveInfo::release_framework_instance_info() {
  clear_has_framework_instance_info();
  ::FwmRcProto::FrameworkInstanceInfo* temp = framework_instance_info_;
  framework_instance_info_ = NULL;
  return temp;
}

// optional string framework_slave_ip = 2;
inline bool EachSlaveInfo::has_framework_slave_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EachSlaveInfo::set_has_framework_slave_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EachSlaveInfo::clear_has_framework_slave_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EachSlaveInfo::clear_framework_slave_ip() {
  if (framework_slave_ip_ != &::google::protobuf::internal::kEmptyString) {
    framework_slave_ip_->clear();
  }
  clear_has_framework_slave_ip();
}
inline const ::std::string& EachSlaveInfo::framework_slave_ip() const {
  return *framework_slave_ip_;
}
inline void EachSlaveInfo::set_framework_slave_ip(const ::std::string& value) {
  set_has_framework_slave_ip();
  if (framework_slave_ip_ == &::google::protobuf::internal::kEmptyString) {
    framework_slave_ip_ = new ::std::string;
  }
  framework_slave_ip_->assign(value);
}
inline void EachSlaveInfo::set_framework_slave_ip(const char* value) {
  set_has_framework_slave_ip();
  if (framework_slave_ip_ == &::google::protobuf::internal::kEmptyString) {
    framework_slave_ip_ = new ::std::string;
  }
  framework_slave_ip_->assign(value);
}
inline void EachSlaveInfo::set_framework_slave_ip(const char* value, size_t size) {
  set_has_framework_slave_ip();
  if (framework_slave_ip_ == &::google::protobuf::internal::kEmptyString) {
    framework_slave_ip_ = new ::std::string;
  }
  framework_slave_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EachSlaveInfo::mutable_framework_slave_ip() {
  set_has_framework_slave_ip();
  if (framework_slave_ip_ == &::google::protobuf::internal::kEmptyString) {
    framework_slave_ip_ = new ::std::string;
  }
  return framework_slave_ip_;
}
inline ::std::string* EachSlaveInfo::release_framework_slave_ip() {
  clear_has_framework_slave_ip();
  if (framework_slave_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = framework_slave_ip_;
    framework_slave_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 framework_slave_PID = 3;
inline bool EachSlaveInfo::has_framework_slave_pid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EachSlaveInfo::set_has_framework_slave_pid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EachSlaveInfo::clear_has_framework_slave_pid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EachSlaveInfo::clear_framework_slave_pid() {
  framework_slave_pid_ = 0u;
  clear_has_framework_slave_pid();
}
inline ::google::protobuf::uint32 EachSlaveInfo::framework_slave_pid() const {
  return framework_slave_pid_;
}
inline void EachSlaveInfo::set_framework_slave_pid(::google::protobuf::uint32 value) {
  set_has_framework_slave_pid();
  framework_slave_pid_ = value;
}

// -------------------------------------------------------------------

// SuccessSlaveInfo

// repeated .FwmRcProto.EachSlaveInfo success_slave_info = 1;
inline int SuccessSlaveInfo::success_slave_info_size() const {
  return success_slave_info_.size();
}
inline void SuccessSlaveInfo::clear_success_slave_info() {
  success_slave_info_.Clear();
}
inline const ::FwmRcProto::EachSlaveInfo& SuccessSlaveInfo::success_slave_info(int index) const {
  return success_slave_info_.Get(index);
}
inline ::FwmRcProto::EachSlaveInfo* SuccessSlaveInfo::mutable_success_slave_info(int index) {
  return success_slave_info_.Mutable(index);
}
inline ::FwmRcProto::EachSlaveInfo* SuccessSlaveInfo::add_success_slave_info() {
  return success_slave_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FwmRcProto::EachSlaveInfo >&
SuccessSlaveInfo::success_slave_info() const {
  return success_slave_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::FwmRcProto::EachSlaveInfo >*
SuccessSlaveInfo::mutable_success_slave_info() {
  return &success_slave_info_;
}

// -------------------------------------------------------------------

// RequestTaskResource

// repeated .FwmRcProto.AddressResourceInfo task_resource_info = 1;
inline int RequestTaskResource::task_resource_info_size() const {
  return task_resource_info_.size();
}
inline void RequestTaskResource::clear_task_resource_info() {
  task_resource_info_.Clear();
}
inline const ::FwmRcProto::AddressResourceInfo& RequestTaskResource::task_resource_info(int index) const {
  return task_resource_info_.Get(index);
}
inline ::FwmRcProto::AddressResourceInfo* RequestTaskResource::mutable_task_resource_info(int index) {
  return task_resource_info_.Mutable(index);
}
inline ::FwmRcProto::AddressResourceInfo* RequestTaskResource::add_task_resource_info() {
  return task_resource_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FwmRcProto::AddressResourceInfo >&
RequestTaskResource::task_resource_info() const {
  return task_resource_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::FwmRcProto::AddressResourceInfo >*
RequestTaskResource::mutable_task_resource_info() {
  return &task_resource_info_;
}

// -------------------------------------------------------------------

// ResourceAddress

// required .FwmRcProto.NetAddress NC_net_address = 1;
inline bool ResourceAddress::has_nc_net_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResourceAddress::set_has_nc_net_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResourceAddress::clear_has_nc_net_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResourceAddress::clear_nc_net_address() {
  if (nc_net_address_ != NULL) nc_net_address_->::FwmRcProto::NetAddress::Clear();
  clear_has_nc_net_address();
}
inline const ::FwmRcProto::NetAddress& ResourceAddress::nc_net_address() const {
  return nc_net_address_ != NULL ? *nc_net_address_ : *default_instance_->nc_net_address_;
}
inline ::FwmRcProto::NetAddress* ResourceAddress::mutable_nc_net_address() {
  set_has_nc_net_address();
  if (nc_net_address_ == NULL) nc_net_address_ = new ::FwmRcProto::NetAddress;
  return nc_net_address_;
}
inline ::FwmRcProto::NetAddress* ResourceAddress::release_nc_net_address() {
  clear_has_nc_net_address();
  ::FwmRcProto::NetAddress* temp = nc_net_address_;
  nc_net_address_ = NULL;
  return temp;
}

// optional .FwmRcProto.FrameworkInstanceInfo framework_instance_info = 2;
inline bool ResourceAddress::has_framework_instance_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResourceAddress::set_has_framework_instance_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResourceAddress::clear_has_framework_instance_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResourceAddress::clear_framework_instance_info() {
  if (framework_instance_info_ != NULL) framework_instance_info_->::FwmRcProto::FrameworkInstanceInfo::Clear();
  clear_has_framework_instance_info();
}
inline const ::FwmRcProto::FrameworkInstanceInfo& ResourceAddress::framework_instance_info() const {
  return framework_instance_info_ != NULL ? *framework_instance_info_ : *default_instance_->framework_instance_info_;
}
inline ::FwmRcProto::FrameworkInstanceInfo* ResourceAddress::mutable_framework_instance_info() {
  set_has_framework_instance_info();
  if (framework_instance_info_ == NULL) framework_instance_info_ = new ::FwmRcProto::FrameworkInstanceInfo;
  return framework_instance_info_;
}
inline ::FwmRcProto::FrameworkInstanceInfo* ResourceAddress::release_framework_instance_info() {
  clear_has_framework_instance_info();
  ::FwmRcProto::FrameworkInstanceInfo* temp = framework_instance_info_;
  framework_instance_info_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// RespondRequestTaskResource

// repeated .FwmRcProto.ResourceAddress resource_address = 1;
inline int RespondRequestTaskResource::resource_address_size() const {
  return resource_address_.size();
}
inline void RespondRequestTaskResource::clear_resource_address() {
  resource_address_.Clear();
}
inline const ::FwmRcProto::ResourceAddress& RespondRequestTaskResource::resource_address(int index) const {
  return resource_address_.Get(index);
}
inline ::FwmRcProto::ResourceAddress* RespondRequestTaskResource::mutable_resource_address(int index) {
  return resource_address_.Mutable(index);
}
inline ::FwmRcProto::ResourceAddress* RespondRequestTaskResource::add_resource_address() {
  return resource_address_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FwmRcProto::ResourceAddress >&
RespondRequestTaskResource::resource_address() const {
  return resource_address_;
}
inline ::google::protobuf::RepeatedPtrField< ::FwmRcProto::ResourceAddress >*
RespondRequestTaskResource::mutable_resource_address() {
  return &resource_address_;
}

// -------------------------------------------------------------------

// ReturnTaskResource

// repeated .FwmRcProto.AddressResourceInfo task_resource_info = 1;
inline int ReturnTaskResource::task_resource_info_size() const {
  return task_resource_info_.size();
}
inline void ReturnTaskResource::clear_task_resource_info() {
  task_resource_info_.Clear();
}
inline const ::FwmRcProto::AddressResourceInfo& ReturnTaskResource::task_resource_info(int index) const {
  return task_resource_info_.Get(index);
}
inline ::FwmRcProto::AddressResourceInfo* ReturnTaskResource::mutable_task_resource_info(int index) {
  return task_resource_info_.Mutable(index);
}
inline ::FwmRcProto::AddressResourceInfo* ReturnTaskResource::add_task_resource_info() {
  return task_resource_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FwmRcProto::AddressResourceInfo >&
ReturnTaskResource::task_resource_info() const {
  return task_resource_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::FwmRcProto::AddressResourceInfo >*
ReturnTaskResource::mutable_task_resource_info() {
  return &task_resource_info_;
}

// -------------------------------------------------------------------

// IPProcessInfo

// required string ip = 1;
inline bool IPProcessInfo::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IPProcessInfo::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IPProcessInfo::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IPProcessInfo::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& IPProcessInfo::ip() const {
  return *ip_;
}
inline void IPProcessInfo::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void IPProcessInfo::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void IPProcessInfo::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IPProcessInfo::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* IPProcessInfo::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 process_id = 2;
inline bool IPProcessInfo::has_process_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IPProcessInfo::set_has_process_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IPProcessInfo::clear_has_process_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IPProcessInfo::clear_process_id() {
  process_id_ = 0u;
  clear_has_process_id();
}
inline ::google::protobuf::uint32 IPProcessInfo::process_id() const {
  return process_id_;
}
inline void IPProcessInfo::set_process_id(::google::protobuf::uint32 value) {
  set_has_process_id();
  process_id_ = value;
}

// -------------------------------------------------------------------

// StopModuleInfo

// required .FwmRcProto.FrameworkInstanceInfo framework_Instance = 1;
inline bool StopModuleInfo::has_framework_instance() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StopModuleInfo::set_has_framework_instance() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StopModuleInfo::clear_has_framework_instance() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StopModuleInfo::clear_framework_instance() {
  if (framework_instance_ != NULL) framework_instance_->::FwmRcProto::FrameworkInstanceInfo::Clear();
  clear_has_framework_instance();
}
inline const ::FwmRcProto::FrameworkInstanceInfo& StopModuleInfo::framework_instance() const {
  return framework_instance_ != NULL ? *framework_instance_ : *default_instance_->framework_instance_;
}
inline ::FwmRcProto::FrameworkInstanceInfo* StopModuleInfo::mutable_framework_instance() {
  set_has_framework_instance();
  if (framework_instance_ == NULL) framework_instance_ = new ::FwmRcProto::FrameworkInstanceInfo;
  return framework_instance_;
}
inline ::FwmRcProto::FrameworkInstanceInfo* StopModuleInfo::release_framework_instance() {
  clear_has_framework_instance();
  ::FwmRcProto::FrameworkInstanceInfo* temp = framework_instance_;
  framework_instance_ = NULL;
  return temp;
}

// repeated .FwmRcProto.IPProcessInfo ip_process = 2;
inline int StopModuleInfo::ip_process_size() const {
  return ip_process_.size();
}
inline void StopModuleInfo::clear_ip_process() {
  ip_process_.Clear();
}
inline const ::FwmRcProto::IPProcessInfo& StopModuleInfo::ip_process(int index) const {
  return ip_process_.Get(index);
}
inline ::FwmRcProto::IPProcessInfo* StopModuleInfo::mutable_ip_process(int index) {
  return ip_process_.Mutable(index);
}
inline ::FwmRcProto::IPProcessInfo* StopModuleInfo::add_ip_process() {
  return ip_process_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FwmRcProto::IPProcessInfo >&
StopModuleInfo::ip_process() const {
  return ip_process_;
}
inline ::google::protobuf::RepeatedPtrField< ::FwmRcProto::IPProcessInfo >*
StopModuleInfo::mutable_ip_process() {
  return &ip_process_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace FwmRcProto

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_FwmRcProtocol_2eproto__INCLUDED
